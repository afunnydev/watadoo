// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"os"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = os.Getenv("PRISMA_ENDPOINT")
var Secret = os.Getenv("PRISMA_SECRET")

func (client *Client) Event(params EventWhereUniqueInput) *EventExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"EventWhereUniqueInput!", "Event"},
		"event",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

type EventsParams struct {
	Where   *EventWhereInput   `json:"where,omitempty"`
	OrderBy *EventOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Events(params *EventsParams) *EventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EventWhereInput", "EventOrderByInput", "Event"},
		"events",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExecArray{ret}
}

type EventsConnectionParams struct {
	Where   *EventWhereInput   `json:"where,omitempty"`
	OrderBy *EventOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) EventsConnection(params *EventsConnectionParams) *EventConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EventWhereInput", "EventOrderByInput", "Event"},
		"eventsConnection",
		[]string{"edges", "pageInfo"})

	return &EventConnectionExec{ret}
}

func (client *Client) EventOccurrence(params EventOccurrenceWhereUniqueInput) *EventOccurrenceExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"EventOccurrenceWhereUniqueInput!", "EventOccurrence"},
		"eventOccurrence",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExec{ret}
}

type EventOccurrencesParams struct {
	Where   *EventOccurrenceWhereInput   `json:"where,omitempty"`
	OrderBy *EventOccurrenceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) EventOccurrences(params *EventOccurrencesParams) *EventOccurrenceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EventOccurrenceWhereInput", "EventOccurrenceOrderByInput", "EventOccurrence"},
		"eventOccurrences",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExecArray{ret}
}

type EventOccurrencesConnectionParams struct {
	Where   *EventOccurrenceWhereInput   `json:"where,omitempty"`
	OrderBy *EventOccurrenceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) EventOccurrencesConnection(params *EventOccurrencesConnectionParams) *EventOccurrenceConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EventOccurrenceWhereInput", "EventOccurrenceOrderByInput", "EventOccurrence"},
		"eventOccurrencesConnection",
		[]string{"edges", "pageInfo"})

	return &EventOccurrenceConnectionExec{ret}
}

func (client *Client) RequestedCity(params RequestedCityWhereUniqueInput) *RequestedCityExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RequestedCityWhereUniqueInput!", "RequestedCity"},
		"requestedCity",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExec{ret}
}

type RequestedCitiesParams struct {
	Where   *RequestedCityWhereInput   `json:"where,omitempty"`
	OrderBy *RequestedCityOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) RequestedCities(params *RequestedCitiesParams) *RequestedCityExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RequestedCityWhereInput", "RequestedCityOrderByInput", "RequestedCity"},
		"requestedCities",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExecArray{ret}
}

type RequestedCitiesConnectionParams struct {
	Where   *RequestedCityWhereInput   `json:"where,omitempty"`
	OrderBy *RequestedCityOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) RequestedCitiesConnection(params *RequestedCitiesConnectionParams) *RequestedCityConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RequestedCitieWhereInput", "RequestedCitieOrderByInput", "RequestedCitie"},
		"requestedCitiesConnection",
		[]string{"edges", "pageInfo"})

	return &RequestedCityConnectionExec{ret}
}

func (client *Client) Search(params SearchWhereUniqueInput) *SearchExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"SearchWhereUniqueInput!", "Search"},
		"search",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExec{ret}
}

type SearchesParams struct {
	Where   *SearchWhereInput   `json:"where,omitempty"`
	OrderBy *SearchOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Searches(params *SearchesParams) *SearchExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SearchWhereInput", "SearchOrderByInput", "Search"},
		"searches",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExecArray{ret}
}

type SearchesConnectionParams struct {
	Where   *SearchWhereInput   `json:"where,omitempty"`
	OrderBy *SearchOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) SearchesConnection(params *SearchesConnectionParams) *SearchConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SearcheWhereInput", "SearcheOrderByInput", "Searche"},
		"searchesConnection",
		[]string{"edges", "pageInfo"})

	return &SearchConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) Venue(params VenueWhereUniqueInput) *VenueExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"VenueWhereUniqueInput!", "Venue"},
		"venue",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

type VenuesParams struct {
	Where   *VenueWhereInput   `json:"where,omitempty"`
	OrderBy *VenueOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Venues(params *VenuesParams) *VenueExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"VenueWhereInput", "VenueOrderByInput", "Venue"},
		"venues",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExecArray{ret}
}

type VenuesConnectionParams struct {
	Where   *VenueWhereInput   `json:"where,omitempty"`
	OrderBy *VenueOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) VenuesConnection(params *VenuesConnectionParams) *VenueConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"VenueWhereInput", "VenueOrderByInput", "Venue"},
		"venuesConnection",
		[]string{"edges", "pageInfo"})

	return &VenueConnectionExec{ret}
}

func (client *Client) CreateEvent(params EventCreateInput) *EventExec {
	ret := client.Client.Create(
		params,
		[2]string{"EventCreateInput!", "Event"},
		"createEvent",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

type EventUpdateParams struct {
	Data  EventUpdateInput      `json:"data"`
	Where EventWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateEvent(params EventUpdateParams) *EventExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"EventUpdateInput!", "EventWhereUniqueInput!", "Event"},
		"updateEvent",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

type EventUpdateManyParams struct {
	Data  EventUpdateManyMutationInput `json:"data"`
	Where *EventWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEvents(params EventUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EventUpdateManyMutationInput!", "EventWhereInput"},
		"updateManyEvents")
	return &BatchPayloadExec{exec}
}

type EventUpsertParams struct {
	Where  EventWhereUniqueInput `json:"where"`
	Create EventCreateInput      `json:"create"`
	Update EventUpdateInput      `json:"update"`
}

func (client *Client) UpsertEvent(params EventUpsertParams) *EventExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"EventWhereUniqueInput!", "EventCreateInput!", "EventUpdateInput!", "Event"},
		"upsertEvent",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

func (client *Client) DeleteEvent(params EventWhereUniqueInput) *EventExec {
	ret := client.Client.Delete(
		params,
		[2]string{"EventWhereUniqueInput!", "Event"},
		"deleteEvent",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

func (client *Client) DeleteManyEvents(params *EventWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EventWhereInput", "deleteManyEvents")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateEventOccurrence(params EventOccurrenceCreateInput) *EventOccurrenceExec {
	ret := client.Client.Create(
		params,
		[2]string{"EventOccurrenceCreateInput!", "EventOccurrence"},
		"createEventOccurrence",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExec{ret}
}

type EventOccurrenceUpdateParams struct {
	Data  EventOccurrenceUpdateInput      `json:"data"`
	Where EventOccurrenceWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateEventOccurrence(params EventOccurrenceUpdateParams) *EventOccurrenceExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"EventOccurrenceUpdateInput!", "EventOccurrenceWhereUniqueInput!", "EventOccurrence"},
		"updateEventOccurrence",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExec{ret}
}

type EventOccurrenceUpdateManyParams struct {
	Data  EventOccurrenceUpdateManyMutationInput `json:"data"`
	Where *EventOccurrenceWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEventOccurrences(params EventOccurrenceUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EventOccurrenceUpdateManyMutationInput!", "EventOccurrenceWhereInput"},
		"updateManyEventOccurrences")
	return &BatchPayloadExec{exec}
}

type EventOccurrenceUpsertParams struct {
	Where  EventOccurrenceWhereUniqueInput `json:"where"`
	Create EventOccurrenceCreateInput      `json:"create"`
	Update EventOccurrenceUpdateInput      `json:"update"`
}

func (client *Client) UpsertEventOccurrence(params EventOccurrenceUpsertParams) *EventOccurrenceExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"EventOccurrenceWhereUniqueInput!", "EventOccurrenceCreateInput!", "EventOccurrenceUpdateInput!", "EventOccurrence"},
		"upsertEventOccurrence",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExec{ret}
}

func (client *Client) DeleteEventOccurrence(params EventOccurrenceWhereUniqueInput) *EventOccurrenceExec {
	ret := client.Client.Delete(
		params,
		[2]string{"EventOccurrenceWhereUniqueInput!", "EventOccurrence"},
		"deleteEventOccurrence",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExec{ret}
}

func (client *Client) DeleteManyEventOccurrences(params *EventOccurrenceWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EventOccurrenceWhereInput", "deleteManyEventOccurrences")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRequestedCity(params RequestedCityCreateInput) *RequestedCityExec {
	ret := client.Client.Create(
		params,
		[2]string{"RequestedCityCreateInput!", "RequestedCity"},
		"createRequestedCity",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExec{ret}
}

type RequestedCityUpdateParams struct {
	Data  RequestedCityUpdateInput      `json:"data"`
	Where RequestedCityWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRequestedCity(params RequestedCityUpdateParams) *RequestedCityExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RequestedCityUpdateInput!", "RequestedCityWhereUniqueInput!", "RequestedCity"},
		"updateRequestedCity",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExec{ret}
}

type RequestedCityUpdateManyParams struct {
	Data  RequestedCityUpdateManyMutationInput `json:"data"`
	Where *RequestedCityWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRequestedCities(params RequestedCityUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RequestedCityUpdateManyMutationInput!", "RequestedCityWhereInput"},
		"updateManyRequestedCities")
	return &BatchPayloadExec{exec}
}

type RequestedCityUpsertParams struct {
	Where  RequestedCityWhereUniqueInput `json:"where"`
	Create RequestedCityCreateInput      `json:"create"`
	Update RequestedCityUpdateInput      `json:"update"`
}

func (client *Client) UpsertRequestedCity(params RequestedCityUpsertParams) *RequestedCityExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RequestedCityWhereUniqueInput!", "RequestedCityCreateInput!", "RequestedCityUpdateInput!", "RequestedCity"},
		"upsertRequestedCity",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExec{ret}
}

func (client *Client) DeleteRequestedCity(params RequestedCityWhereUniqueInput) *RequestedCityExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RequestedCityWhereUniqueInput!", "RequestedCity"},
		"deleteRequestedCity",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExec{ret}
}

func (client *Client) DeleteManyRequestedCities(params *RequestedCityWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RequestedCityWhereInput", "deleteManyRequestedCities")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateSearch(params SearchCreateInput) *SearchExec {
	ret := client.Client.Create(
		params,
		[2]string{"SearchCreateInput!", "Search"},
		"createSearch",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExec{ret}
}

type SearchUpdateParams struct {
	Data  SearchUpdateInput      `json:"data"`
	Where SearchWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateSearch(params SearchUpdateParams) *SearchExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"SearchUpdateInput!", "SearchWhereUniqueInput!", "Search"},
		"updateSearch",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExec{ret}
}

type SearchUpdateManyParams struct {
	Data  SearchUpdateManyMutationInput `json:"data"`
	Where *SearchWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManySearches(params SearchUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"SearchUpdateManyMutationInput!", "SearchWhereInput"},
		"updateManySearches")
	return &BatchPayloadExec{exec}
}

type SearchUpsertParams struct {
	Where  SearchWhereUniqueInput `json:"where"`
	Create SearchCreateInput      `json:"create"`
	Update SearchUpdateInput      `json:"update"`
}

func (client *Client) UpsertSearch(params SearchUpsertParams) *SearchExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"SearchWhereUniqueInput!", "SearchCreateInput!", "SearchUpdateInput!", "Search"},
		"upsertSearch",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExec{ret}
}

func (client *Client) DeleteSearch(params SearchWhereUniqueInput) *SearchExec {
	ret := client.Client.Delete(
		params,
		[2]string{"SearchWhereUniqueInput!", "Search"},
		"deleteSearch",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExec{ret}
}

func (client *Client) DeleteManySearches(params *SearchWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "SearchWhereInput", "deleteManySearches")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateVenue(params VenueCreateInput) *VenueExec {
	ret := client.Client.Create(
		params,
		[2]string{"VenueCreateInput!", "Venue"},
		"createVenue",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

type VenueUpdateParams struct {
	Data  VenueUpdateInput      `json:"data"`
	Where VenueWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateVenue(params VenueUpdateParams) *VenueExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"VenueUpdateInput!", "VenueWhereUniqueInput!", "Venue"},
		"updateVenue",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

type VenueUpdateManyParams struct {
	Data  VenueUpdateManyMutationInput `json:"data"`
	Where *VenueWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyVenues(params VenueUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"VenueUpdateManyMutationInput!", "VenueWhereInput"},
		"updateManyVenues")
	return &BatchPayloadExec{exec}
}

type VenueUpsertParams struct {
	Where  VenueWhereUniqueInput `json:"where"`
	Create VenueCreateInput      `json:"create"`
	Update VenueUpdateInput      `json:"update"`
}

func (client *Client) UpsertVenue(params VenueUpsertParams) *VenueExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"VenueWhereUniqueInput!", "VenueCreateInput!", "VenueUpdateInput!", "Venue"},
		"upsertVenue",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

func (client *Client) DeleteVenue(params VenueWhereUniqueInput) *VenueExec {
	ret := client.Client.Delete(
		params,
		[2]string{"VenueWhereUniqueInput!", "Venue"},
		"deleteVenue",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

func (client *Client) DeleteManyVenues(params *VenueWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "VenueWhereInput", "deleteManyVenues")
	return &BatchPayloadExec{exec}
}

type City string

const (
	CityGatineau City = "GATINEAU"
	CityOttawa   City = "OTTAWA"
	CityMontreal City = "MONTREAL"
	CityQuebec   City = "QUEBEC"
	CityToronto  City = "TORONTO"
)

type EventOrderByInput string

const (
	EventOrderByInputIDAsc                    EventOrderByInput = "id_ASC"
	EventOrderByInputIDDesc                   EventOrderByInput = "id_DESC"
	EventOrderByInputNameAsc                  EventOrderByInput = "name_ASC"
	EventOrderByInputNameDesc                 EventOrderByInput = "name_DESC"
	EventOrderByInputDescriptionAsc           EventOrderByInput = "description_ASC"
	EventOrderByInputDescriptionDesc          EventOrderByInput = "description_DESC"
	EventOrderByInputShortDescriptionAsc      EventOrderByInput = "shortDescription_ASC"
	EventOrderByInputShortDescriptionDesc     EventOrderByInput = "shortDescription_DESC"
	EventOrderByInputLinkAsc                  EventOrderByInput = "link_ASC"
	EventOrderByInputLinkDesc                 EventOrderByInput = "link_DESC"
	EventOrderByInputImageUrlAsc              EventOrderByInput = "imageUrl_ASC"
	EventOrderByInputImageUrlDesc             EventOrderByInput = "imageUrl_DESC"
	EventOrderByInputNextOccurrenceDateAsc    EventOrderByInput = "nextOccurrenceDate_ASC"
	EventOrderByInputNextOccurrenceDateDesc   EventOrderByInput = "nextOccurrenceDate_DESC"
	EventOrderByInputPriceAsc                 EventOrderByInput = "price_ASC"
	EventOrderByInputPriceDesc                EventOrderByInput = "price_DESC"
	EventOrderByInputCategoryAsc              EventOrderByInput = "category_ASC"
	EventOrderByInputCategoryDesc             EventOrderByInput = "category_DESC"
	EventOrderByInputTagsAsc                  EventOrderByInput = "tags_ASC"
	EventOrderByInputTagsDesc                 EventOrderByInput = "tags_DESC"
	EventOrderByInputTicketUrlAsc             EventOrderByInput = "ticketUrl_ASC"
	EventOrderByInputTicketUrlDesc            EventOrderByInput = "ticketUrl_DESC"
	EventOrderByInputSourceAsc                EventOrderByInput = "source_ASC"
	EventOrderByInputSourceDesc               EventOrderByInput = "source_DESC"
	EventOrderByInputWpFrIdAsc                EventOrderByInput = "wpFrId_ASC"
	EventOrderByInputWpFrIdDesc               EventOrderByInput = "wpFrId_DESC"
	EventOrderByInputWpEnIdAsc                EventOrderByInput = "wpEnId_ASC"
	EventOrderByInputWpEnIdDesc               EventOrderByInput = "wpEnId_DESC"
	EventOrderByInputPossibleDuplicateAsc     EventOrderByInput = "possibleDuplicate_ASC"
	EventOrderByInputPossibleDuplicateDesc    EventOrderByInput = "possibleDuplicate_DESC"
	EventOrderByInputImportNotesAsc           EventOrderByInput = "importNotes_ASC"
	EventOrderByInputImportNotesDesc          EventOrderByInput = "importNotes_DESC"
	EventOrderByInputIsRecurringAsc           EventOrderByInput = "isRecurring_ASC"
	EventOrderByInputIsRecurringDesc          EventOrderByInput = "isRecurring_DESC"
	EventOrderByInputRecurrencePatternAsc     EventOrderByInput = "recurrencePattern_ASC"
	EventOrderByInputRecurrencePatternDesc    EventOrderByInput = "recurrencePattern_DESC"
	EventOrderByInputOccurrencesAreUniqueAsc  EventOrderByInput = "occurrencesAreUnique_ASC"
	EventOrderByInputOccurrencesAreUniqueDesc EventOrderByInput = "occurrencesAreUnique_DESC"
	EventOrderByInputCreatedAtAsc             EventOrderByInput = "createdAt_ASC"
	EventOrderByInputCreatedAtDesc            EventOrderByInput = "createdAt_DESC"
	EventOrderByInputUpdatedAtAsc             EventOrderByInput = "updatedAt_ASC"
	EventOrderByInputUpdatedAtDesc            EventOrderByInput = "updatedAt_DESC"
)

type Relationship string

const (
	RelationshipCouple  Relationship = "COUPLE"
	RelationshipSingle  Relationship = "SINGLE"
	RelationshipMarried Relationship = "MARRIED"
	RelationshipOther   Relationship = "OTHER"
	RelationshipNone    Relationship = "NONE"
)

type VenueOrderByInput string

const (
	VenueOrderByInputIDAsc                 VenueOrderByInput = "id_ASC"
	VenueOrderByInputIDDesc                VenueOrderByInput = "id_DESC"
	VenueOrderByInputNameFrAsc             VenueOrderByInput = "nameFr_ASC"
	VenueOrderByInputNameFrDesc            VenueOrderByInput = "nameFr_DESC"
	VenueOrderByInputNameEnAsc             VenueOrderByInput = "nameEn_ASC"
	VenueOrderByInputNameEnDesc            VenueOrderByInput = "nameEn_DESC"
	VenueOrderByInputLatAsc                VenueOrderByInput = "lat_ASC"
	VenueOrderByInputLatDesc               VenueOrderByInput = "lat_DESC"
	VenueOrderByInputLongAsc               VenueOrderByInput = "long_ASC"
	VenueOrderByInputLongDesc              VenueOrderByInput = "long_DESC"
	VenueOrderByInputCityAsc               VenueOrderByInput = "city_ASC"
	VenueOrderByInputCityDesc              VenueOrderByInput = "city_DESC"
	VenueOrderByInputAddressAsc            VenueOrderByInput = "address_ASC"
	VenueOrderByInputAddressDesc           VenueOrderByInput = "address_DESC"
	VenueOrderByInputZipAsc                VenueOrderByInput = "zip_ASC"
	VenueOrderByInputZipDesc               VenueOrderByInput = "zip_DESC"
	VenueOrderByInputCountryAsc            VenueOrderByInput = "country_ASC"
	VenueOrderByInputCountryDesc           VenueOrderByInput = "country_DESC"
	VenueOrderByInputUrlAsc                VenueOrderByInput = "url_ASC"
	VenueOrderByInputUrlDesc               VenueOrderByInput = "url_DESC"
	VenueOrderByInputWpFrIdAsc             VenueOrderByInput = "wpFrId_ASC"
	VenueOrderByInputWpFrIdDesc            VenueOrderByInput = "wpFrId_DESC"
	VenueOrderByInputWpEnIdAsc             VenueOrderByInput = "wpEnId_ASC"
	VenueOrderByInputWpEnIdDesc            VenueOrderByInput = "wpEnId_DESC"
	VenueOrderByInputPossibleDuplicateAsc  VenueOrderByInput = "possibleDuplicate_ASC"
	VenueOrderByInputPossibleDuplicateDesc VenueOrderByInput = "possibleDuplicate_DESC"
)

type EventOccurrenceOrderByInput string

const (
	EventOccurrenceOrderByInputIDAsc           EventOccurrenceOrderByInput = "id_ASC"
	EventOccurrenceOrderByInputIDDesc          EventOccurrenceOrderByInput = "id_DESC"
	EventOccurrenceOrderByInputNameAsc         EventOccurrenceOrderByInput = "name_ASC"
	EventOccurrenceOrderByInputNameDesc        EventOccurrenceOrderByInput = "name_DESC"
	EventOccurrenceOrderByInputDescriptionAsc  EventOccurrenceOrderByInput = "description_ASC"
	EventOccurrenceOrderByInputDescriptionDesc EventOccurrenceOrderByInput = "description_DESC"
	EventOccurrenceOrderByInputImageUrlAsc     EventOccurrenceOrderByInput = "imageUrl_ASC"
	EventOccurrenceOrderByInputImageUrlDesc    EventOccurrenceOrderByInput = "imageUrl_DESC"
	EventOccurrenceOrderByInputStartDateAsc    EventOccurrenceOrderByInput = "startDate_ASC"
	EventOccurrenceOrderByInputStartDateDesc   EventOccurrenceOrderByInput = "startDate_DESC"
	EventOccurrenceOrderByInputEndDateAsc      EventOccurrenceOrderByInput = "endDate_ASC"
	EventOccurrenceOrderByInputEndDateDesc     EventOccurrenceOrderByInput = "endDate_DESC"
	EventOccurrenceOrderByInputLatAsc          EventOccurrenceOrderByInput = "lat_ASC"
	EventOccurrenceOrderByInputLatDesc         EventOccurrenceOrderByInput = "lat_DESC"
	EventOccurrenceOrderByInputLongAsc         EventOccurrenceOrderByInput = "long_ASC"
	EventOccurrenceOrderByInputLongDesc        EventOccurrenceOrderByInput = "long_DESC"
	EventOccurrenceOrderByInputPriceAsc        EventOccurrenceOrderByInput = "price_ASC"
	EventOccurrenceOrderByInputPriceDesc       EventOccurrenceOrderByInput = "price_DESC"
	EventOccurrenceOrderByInputCityAsc         EventOccurrenceOrderByInput = "city_ASC"
	EventOccurrenceOrderByInputCityDesc        EventOccurrenceOrderByInput = "city_DESC"
	EventOccurrenceOrderByInputTicketUrlAsc    EventOccurrenceOrderByInput = "ticketUrl_ASC"
	EventOccurrenceOrderByInputTicketUrlDesc   EventOccurrenceOrderByInput = "ticketUrl_DESC"
	EventOccurrenceOrderByInputCreatedAtAsc    EventOccurrenceOrderByInput = "createdAt_ASC"
	EventOccurrenceOrderByInputCreatedAtDesc   EventOccurrenceOrderByInput = "createdAt_DESC"
)

type EventCategory string

const (
	EventCategoryActivites EventCategory = "ACTIVITES"
	EventCategoryComedy    EventCategory = "COMEDY"
	EventCategoryFamily    EventCategory = "FAMILY"
	EventCategoryFestivals EventCategory = "FESTIVALS"
	EventCategoryFood      EventCategory = "FOOD"
	EventCategoryMuseums   EventCategory = "MUSEUMS"
	EventCategoryMusic     EventCategory = "MUSIC"
	EventCategorySports    EventCategory = "SPORTS"
	EventCategoryTheater   EventCategory = "THEATER"
	EventCategoryVariety   EventCategory = "VARIETY"
	EventCategoryOther     EventCategory = "OTHER"
	EventCategoryUnknown   EventCategory = "UNKNOWN"
)

type Sex string

const (
	SexMale   Sex = "MALE"
	SexFemale Sex = "FEMALE"
	SexOther  Sex = "OTHER"
)

type Permission string

const (
	PermissionUser        Permission = "USER"
	PermissionManageevent Permission = "MANAGEEVENT"
	PermissionAdmin       Permission = "ADMIN"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc                      UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc                     UserOrderByInput = "id_DESC"
	UserOrderByInputFacebookidAsc              UserOrderByInput = "facebookid_ASC"
	UserOrderByInputFacebookidDesc             UserOrderByInput = "facebookid_DESC"
	UserOrderByInputFnameAsc                   UserOrderByInput = "fname_ASC"
	UserOrderByInputFnameDesc                  UserOrderByInput = "fname_DESC"
	UserOrderByInputLnameAsc                   UserOrderByInput = "lname_ASC"
	UserOrderByInputLnameDesc                  UserOrderByInput = "lname_DESC"
	UserOrderByInputPictureAsc                 UserOrderByInput = "picture_ASC"
	UserOrderByInputPictureDesc                UserOrderByInput = "picture_DESC"
	UserOrderByInputEmailAsc                   UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc                  UserOrderByInput = "email_DESC"
	UserOrderByInputPasswordAsc                UserOrderByInput = "password_ASC"
	UserOrderByInputPasswordDesc               UserOrderByInput = "password_DESC"
	UserOrderByInputSexAsc                     UserOrderByInput = "sex_ASC"
	UserOrderByInputSexDesc                    UserOrderByInput = "sex_DESC"
	UserOrderByInputAgeAsc                     UserOrderByInput = "age_ASC"
	UserOrderByInputAgeDesc                    UserOrderByInput = "age_DESC"
	UserOrderByInputCityAsc                    UserOrderByInput = "city_ASC"
	UserOrderByInputCityDesc                   UserOrderByInput = "city_DESC"
	UserOrderByInputRelationshipAsc            UserOrderByInput = "relationship_ASC"
	UserOrderByInputRelationshipDesc           UserOrderByInput = "relationship_DESC"
	UserOrderByInputCreatedAtAsc               UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc              UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc               UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc              UserOrderByInput = "updatedAt_DESC"
	UserOrderByInputLastInteractionAsc         UserOrderByInput = "lastInteraction_ASC"
	UserOrderByInputLastInteractionDesc        UserOrderByInput = "lastInteraction_DESC"
	UserOrderByInputMessengerNotificationsAsc  UserOrderByInput = "messengerNotifications_ASC"
	UserOrderByInputMessengerNotificationsDesc UserOrderByInput = "messengerNotifications_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type Notification string

const (
	NotificationAnytime  Notification = "ANYTIME"
	NotificationWeekly   Notification = "WEEKLY"
	NotificationBiweekly Notification = "BIWEEKLY"
	NotificationMonthly  Notification = "MONTHLY"
	NotificationNever    Notification = "NEVER"
)

type RequestedCityOrderByInput string

const (
	RequestedCityOrderByInputIDAsc         RequestedCityOrderByInput = "id_ASC"
	RequestedCityOrderByInputIDDesc        RequestedCityOrderByInput = "id_DESC"
	RequestedCityOrderByInputCityAsc       RequestedCityOrderByInput = "city_ASC"
	RequestedCityOrderByInputCityDesc      RequestedCityOrderByInput = "city_DESC"
	RequestedCityOrderByInputSendEmailAsc  RequestedCityOrderByInput = "sendEmail_ASC"
	RequestedCityOrderByInputSendEmailDesc RequestedCityOrderByInput = "sendEmail_DESC"
)

type SearchOrderByInput string

const (
	SearchOrderByInputIDAsc         SearchOrderByInput = "id_ASC"
	SearchOrderByInputIDDesc        SearchOrderByInput = "id_DESC"
	SearchOrderByInputCreatedAtAsc  SearchOrderByInput = "createdAt_ASC"
	SearchOrderByInputCreatedAtDesc SearchOrderByInput = "createdAt_DESC"
	SearchOrderByInputCityAsc       SearchOrderByInput = "city_ASC"
	SearchOrderByInputCityDesc      SearchOrderByInput = "city_DESC"
	SearchOrderByInputStartDateAsc  SearchOrderByInput = "startDate_ASC"
	SearchOrderByInputStartDateDesc SearchOrderByInput = "startDate_DESC"
	SearchOrderByInputEndDateAsc    SearchOrderByInput = "endDate_ASC"
	SearchOrderByInputEndDateDesc   SearchOrderByInput = "endDate_DESC"
	SearchOrderByInputInfoAsc       SearchOrderByInput = "info_ASC"
	SearchOrderByInputInfoDesc      SearchOrderByInput = "info_DESC"
	SearchOrderByInputSuggestedAsc  SearchOrderByInput = "suggested_ASC"
	SearchOrderByInputSuggestedDesc SearchOrderByInput = "suggested_DESC"
)

type EventOccurrenceScalarWhereInput struct {
	ID                       *string                           `json:"id,omitempty"`
	IDNot                    *string                           `json:"id_not,omitempty"`
	IDIn                     []string                          `json:"id_in,omitempty"`
	IDNotIn                  []string                          `json:"id_not_in,omitempty"`
	IDLt                     *string                           `json:"id_lt,omitempty"`
	IDLte                    *string                           `json:"id_lte,omitempty"`
	IDGt                     *string                           `json:"id_gt,omitempty"`
	IDGte                    *string                           `json:"id_gte,omitempty"`
	IDContains               *string                           `json:"id_contains,omitempty"`
	IDNotContains            *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                           `json:"id_not_ends_with,omitempty"`
	Name                     *string                           `json:"name,omitempty"`
	NameNot                  *string                           `json:"name_not,omitempty"`
	NameIn                   []string                          `json:"name_in,omitempty"`
	NameNotIn                []string                          `json:"name_not_in,omitempty"`
	NameLt                   *string                           `json:"name_lt,omitempty"`
	NameLte                  *string                           `json:"name_lte,omitempty"`
	NameGt                   *string                           `json:"name_gt,omitempty"`
	NameGte                  *string                           `json:"name_gte,omitempty"`
	NameContains             *string                           `json:"name_contains,omitempty"`
	NameNotContains          *string                           `json:"name_not_contains,omitempty"`
	NameStartsWith           *string                           `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string                           `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string                           `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string                           `json:"name_not_ends_with,omitempty"`
	Description              *string                           `json:"description,omitempty"`
	DescriptionNot           *string                           `json:"description_not,omitempty"`
	DescriptionIn            []string                          `json:"description_in,omitempty"`
	DescriptionNotIn         []string                          `json:"description_not_in,omitempty"`
	DescriptionLt            *string                           `json:"description_lt,omitempty"`
	DescriptionLte           *string                           `json:"description_lte,omitempty"`
	DescriptionGt            *string                           `json:"description_gt,omitempty"`
	DescriptionGte           *string                           `json:"description_gte,omitempty"`
	DescriptionContains      *string                           `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                           `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                           `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                           `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                           `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                           `json:"description_not_ends_with,omitempty"`
	ImageUrl                 *string                           `json:"imageUrl,omitempty"`
	ImageUrlNot              *string                           `json:"imageUrl_not,omitempty"`
	ImageUrlIn               []string                          `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn            []string                          `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt               *string                           `json:"imageUrl_lt,omitempty"`
	ImageUrlLte              *string                           `json:"imageUrl_lte,omitempty"`
	ImageUrlGt               *string                           `json:"imageUrl_gt,omitempty"`
	ImageUrlGte              *string                           `json:"imageUrl_gte,omitempty"`
	ImageUrlContains         *string                           `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains      *string                           `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith       *string                           `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith    *string                           `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith         *string                           `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith      *string                           `json:"imageUrl_not_ends_with,omitempty"`
	StartDate                *string                           `json:"startDate,omitempty"`
	StartDateNot             *string                           `json:"startDate_not,omitempty"`
	StartDateIn              []string                          `json:"startDate_in,omitempty"`
	StartDateNotIn           []string                          `json:"startDate_not_in,omitempty"`
	StartDateLt              *string                           `json:"startDate_lt,omitempty"`
	StartDateLte             *string                           `json:"startDate_lte,omitempty"`
	StartDateGt              *string                           `json:"startDate_gt,omitempty"`
	StartDateGte             *string                           `json:"startDate_gte,omitempty"`
	EndDate                  *string                           `json:"endDate,omitempty"`
	EndDateNot               *string                           `json:"endDate_not,omitempty"`
	EndDateIn                []string                          `json:"endDate_in,omitempty"`
	EndDateNotIn             []string                          `json:"endDate_not_in,omitempty"`
	EndDateLt                *string                           `json:"endDate_lt,omitempty"`
	EndDateLte               *string                           `json:"endDate_lte,omitempty"`
	EndDateGt                *string                           `json:"endDate_gt,omitempty"`
	EndDateGte               *string                           `json:"endDate_gte,omitempty"`
	Lat                      *float64                          `json:"lat,omitempty"`
	LatNot                   *float64                          `json:"lat_not,omitempty"`
	LatIn                    []float64                         `json:"lat_in,omitempty"`
	LatNotIn                 []float64                         `json:"lat_not_in,omitempty"`
	LatLt                    *float64                          `json:"lat_lt,omitempty"`
	LatLte                   *float64                          `json:"lat_lte,omitempty"`
	LatGt                    *float64                          `json:"lat_gt,omitempty"`
	LatGte                   *float64                          `json:"lat_gte,omitempty"`
	Long                     *float64                          `json:"long,omitempty"`
	LongNot                  *float64                          `json:"long_not,omitempty"`
	LongIn                   []float64                         `json:"long_in,omitempty"`
	LongNotIn                []float64                         `json:"long_not_in,omitempty"`
	LongLt                   *float64                          `json:"long_lt,omitempty"`
	LongLte                  *float64                          `json:"long_lte,omitempty"`
	LongGt                   *float64                          `json:"long_gt,omitempty"`
	LongGte                  *float64                          `json:"long_gte,omitempty"`
	Price                    *int32                            `json:"price,omitempty"`
	PriceNot                 *int32                            `json:"price_not,omitempty"`
	PriceIn                  []int32                           `json:"price_in,omitempty"`
	PriceNotIn               []int32                           `json:"price_not_in,omitempty"`
	PriceLt                  *int32                            `json:"price_lt,omitempty"`
	PriceLte                 *int32                            `json:"price_lte,omitempty"`
	PriceGt                  *int32                            `json:"price_gt,omitempty"`
	PriceGte                 *int32                            `json:"price_gte,omitempty"`
	City                     *City                             `json:"city,omitempty"`
	CityNot                  *City                             `json:"city_not,omitempty"`
	CityIn                   []City                            `json:"city_in,omitempty"`
	CityNotIn                []City                            `json:"city_not_in,omitempty"`
	TicketUrl                *string                           `json:"ticketUrl,omitempty"`
	TicketUrlNot             *string                           `json:"ticketUrl_not,omitempty"`
	TicketUrlIn              []string                          `json:"ticketUrl_in,omitempty"`
	TicketUrlNotIn           []string                          `json:"ticketUrl_not_in,omitempty"`
	TicketUrlLt              *string                           `json:"ticketUrl_lt,omitempty"`
	TicketUrlLte             *string                           `json:"ticketUrl_lte,omitempty"`
	TicketUrlGt              *string                           `json:"ticketUrl_gt,omitempty"`
	TicketUrlGte             *string                           `json:"ticketUrl_gte,omitempty"`
	TicketUrlContains        *string                           `json:"ticketUrl_contains,omitempty"`
	TicketUrlNotContains     *string                           `json:"ticketUrl_not_contains,omitempty"`
	TicketUrlStartsWith      *string                           `json:"ticketUrl_starts_with,omitempty"`
	TicketUrlNotStartsWith   *string                           `json:"ticketUrl_not_starts_with,omitempty"`
	TicketUrlEndsWith        *string                           `json:"ticketUrl_ends_with,omitempty"`
	TicketUrlNotEndsWith     *string                           `json:"ticketUrl_not_ends_with,omitempty"`
	CreatedAt                *string                           `json:"createdAt,omitempty"`
	CreatedAtNot             *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                           `json:"createdAt_gte,omitempty"`
	And                      []EventOccurrenceScalarWhereInput `json:"AND,omitempty"`
	Or                       []EventOccurrenceScalarWhereInput `json:"OR,omitempty"`
	Not                      []EventOccurrenceScalarWhereInput `json:"NOT,omitempty"`
}

type EventWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EventCreateWithoutOccurrencesInput struct {
	ID                   *string                           `json:"id,omitempty"`
	Name                 string                            `json:"name"`
	Description          *string                           `json:"description,omitempty"`
	ShortDescription     *string                           `json:"shortDescription,omitempty"`
	Link                 string                            `json:"link"`
	ImageUrl             *string                           `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string                           `json:"nextOccurrenceDate,omitempty"`
	Price                *int32                            `json:"price,omitempty"`
	Venue                *VenueCreateOneWithoutEventsInput `json:"venue,omitempty"`
	Category             *EventCategory                    `json:"category,omitempty"`
	Tags                 *string                           `json:"tags,omitempty"`
	TicketUrl            *string                           `json:"ticketUrl,omitempty"`
	Source               *string                           `json:"source,omitempty"`
	WpFrId               *int32                            `json:"wpFrId,omitempty"`
	WpEnId               *int32                            `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool                             `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string                           `json:"importNotes,omitempty"`
	IsRecurring          *bool                             `json:"isRecurring,omitempty"`
	RecurrencePattern    *string                           `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool                             `json:"occurrencesAreUnique,omitempty"`
}

type EventOccurrenceWhereInput struct {
	ID                       *string                     `json:"id,omitempty"`
	IDNot                    *string                     `json:"id_not,omitempty"`
	IDIn                     []string                    `json:"id_in,omitempty"`
	IDNotIn                  []string                    `json:"id_not_in,omitempty"`
	IDLt                     *string                     `json:"id_lt,omitempty"`
	IDLte                    *string                     `json:"id_lte,omitempty"`
	IDGt                     *string                     `json:"id_gt,omitempty"`
	IDGte                    *string                     `json:"id_gte,omitempty"`
	IDContains               *string                     `json:"id_contains,omitempty"`
	IDNotContains            *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                     `json:"id_not_ends_with,omitempty"`
	Name                     *string                     `json:"name,omitempty"`
	NameNot                  *string                     `json:"name_not,omitempty"`
	NameIn                   []string                    `json:"name_in,omitempty"`
	NameNotIn                []string                    `json:"name_not_in,omitempty"`
	NameLt                   *string                     `json:"name_lt,omitempty"`
	NameLte                  *string                     `json:"name_lte,omitempty"`
	NameGt                   *string                     `json:"name_gt,omitempty"`
	NameGte                  *string                     `json:"name_gte,omitempty"`
	NameContains             *string                     `json:"name_contains,omitempty"`
	NameNotContains          *string                     `json:"name_not_contains,omitempty"`
	NameStartsWith           *string                     `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string                     `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string                     `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string                     `json:"name_not_ends_with,omitempty"`
	Description              *string                     `json:"description,omitempty"`
	DescriptionNot           *string                     `json:"description_not,omitempty"`
	DescriptionIn            []string                    `json:"description_in,omitempty"`
	DescriptionNotIn         []string                    `json:"description_not_in,omitempty"`
	DescriptionLt            *string                     `json:"description_lt,omitempty"`
	DescriptionLte           *string                     `json:"description_lte,omitempty"`
	DescriptionGt            *string                     `json:"description_gt,omitempty"`
	DescriptionGte           *string                     `json:"description_gte,omitempty"`
	DescriptionContains      *string                     `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                     `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                     `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                     `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                     `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                     `json:"description_not_ends_with,omitempty"`
	ImageUrl                 *string                     `json:"imageUrl,omitempty"`
	ImageUrlNot              *string                     `json:"imageUrl_not,omitempty"`
	ImageUrlIn               []string                    `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn            []string                    `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt               *string                     `json:"imageUrl_lt,omitempty"`
	ImageUrlLte              *string                     `json:"imageUrl_lte,omitempty"`
	ImageUrlGt               *string                     `json:"imageUrl_gt,omitempty"`
	ImageUrlGte              *string                     `json:"imageUrl_gte,omitempty"`
	ImageUrlContains         *string                     `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains      *string                     `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith       *string                     `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith    *string                     `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith         *string                     `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith      *string                     `json:"imageUrl_not_ends_with,omitempty"`
	StartDate                *string                     `json:"startDate,omitempty"`
	StartDateNot             *string                     `json:"startDate_not,omitempty"`
	StartDateIn              []string                    `json:"startDate_in,omitempty"`
	StartDateNotIn           []string                    `json:"startDate_not_in,omitempty"`
	StartDateLt              *string                     `json:"startDate_lt,omitempty"`
	StartDateLte             *string                     `json:"startDate_lte,omitempty"`
	StartDateGt              *string                     `json:"startDate_gt,omitempty"`
	StartDateGte             *string                     `json:"startDate_gte,omitempty"`
	EndDate                  *string                     `json:"endDate,omitempty"`
	EndDateNot               *string                     `json:"endDate_not,omitempty"`
	EndDateIn                []string                    `json:"endDate_in,omitempty"`
	EndDateNotIn             []string                    `json:"endDate_not_in,omitempty"`
	EndDateLt                *string                     `json:"endDate_lt,omitempty"`
	EndDateLte               *string                     `json:"endDate_lte,omitempty"`
	EndDateGt                *string                     `json:"endDate_gt,omitempty"`
	EndDateGte               *string                     `json:"endDate_gte,omitempty"`
	Lat                      *float64                    `json:"lat,omitempty"`
	LatNot                   *float64                    `json:"lat_not,omitempty"`
	LatIn                    []float64                   `json:"lat_in,omitempty"`
	LatNotIn                 []float64                   `json:"lat_not_in,omitempty"`
	LatLt                    *float64                    `json:"lat_lt,omitempty"`
	LatLte                   *float64                    `json:"lat_lte,omitempty"`
	LatGt                    *float64                    `json:"lat_gt,omitempty"`
	LatGte                   *float64                    `json:"lat_gte,omitempty"`
	Long                     *float64                    `json:"long,omitempty"`
	LongNot                  *float64                    `json:"long_not,omitempty"`
	LongIn                   []float64                   `json:"long_in,omitempty"`
	LongNotIn                []float64                   `json:"long_not_in,omitempty"`
	LongLt                   *float64                    `json:"long_lt,omitempty"`
	LongLte                  *float64                    `json:"long_lte,omitempty"`
	LongGt                   *float64                    `json:"long_gt,omitempty"`
	LongGte                  *float64                    `json:"long_gte,omitempty"`
	Price                    *int32                      `json:"price,omitempty"`
	PriceNot                 *int32                      `json:"price_not,omitempty"`
	PriceIn                  []int32                     `json:"price_in,omitempty"`
	PriceNotIn               []int32                     `json:"price_not_in,omitempty"`
	PriceLt                  *int32                      `json:"price_lt,omitempty"`
	PriceLte                 *int32                      `json:"price_lte,omitempty"`
	PriceGt                  *int32                      `json:"price_gt,omitempty"`
	PriceGte                 *int32                      `json:"price_gte,omitempty"`
	City                     *City                       `json:"city,omitempty"`
	CityNot                  *City                       `json:"city_not,omitempty"`
	CityIn                   []City                      `json:"city_in,omitempty"`
	CityNotIn                []City                      `json:"city_not_in,omitempty"`
	TicketUrl                *string                     `json:"ticketUrl,omitempty"`
	TicketUrlNot             *string                     `json:"ticketUrl_not,omitempty"`
	TicketUrlIn              []string                    `json:"ticketUrl_in,omitempty"`
	TicketUrlNotIn           []string                    `json:"ticketUrl_not_in,omitempty"`
	TicketUrlLt              *string                     `json:"ticketUrl_lt,omitempty"`
	TicketUrlLte             *string                     `json:"ticketUrl_lte,omitempty"`
	TicketUrlGt              *string                     `json:"ticketUrl_gt,omitempty"`
	TicketUrlGte             *string                     `json:"ticketUrl_gte,omitempty"`
	TicketUrlContains        *string                     `json:"ticketUrl_contains,omitempty"`
	TicketUrlNotContains     *string                     `json:"ticketUrl_not_contains,omitempty"`
	TicketUrlStartsWith      *string                     `json:"ticketUrl_starts_with,omitempty"`
	TicketUrlNotStartsWith   *string                     `json:"ticketUrl_not_starts_with,omitempty"`
	TicketUrlEndsWith        *string                     `json:"ticketUrl_ends_with,omitempty"`
	TicketUrlNotEndsWith     *string                     `json:"ticketUrl_not_ends_with,omitempty"`
	Event                    *EventWhereInput            `json:"event,omitempty"`
	CreatedAt                *string                     `json:"createdAt,omitempty"`
	CreatedAtNot             *string                     `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                     `json:"createdAt_gte,omitempty"`
	And                      []EventOccurrenceWhereInput `json:"AND,omitempty"`
	Or                       []EventOccurrenceWhereInput `json:"OR,omitempty"`
	Not                      []EventOccurrenceWhereInput `json:"NOT,omitempty"`
}

type EventCreateInput struct {
	ID                   *string                                     `json:"id,omitempty"`
	Name                 string                                      `json:"name"`
	Description          *string                                     `json:"description,omitempty"`
	ShortDescription     *string                                     `json:"shortDescription,omitempty"`
	Link                 string                                      `json:"link"`
	ImageUrl             *string                                     `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string                                     `json:"nextOccurrenceDate,omitempty"`
	Price                *int32                                      `json:"price,omitempty"`
	Venue                *VenueCreateOneWithoutEventsInput           `json:"venue,omitempty"`
	Category             *EventCategory                              `json:"category,omitempty"`
	Tags                 *string                                     `json:"tags,omitempty"`
	TicketUrl            *string                                     `json:"ticketUrl,omitempty"`
	Source               *string                                     `json:"source,omitempty"`
	WpFrId               *int32                                      `json:"wpFrId,omitempty"`
	WpEnId               *int32                                      `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool                                       `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string                                     `json:"importNotes,omitempty"`
	IsRecurring          *bool                                       `json:"isRecurring,omitempty"`
	RecurrencePattern    *string                                     `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool                                       `json:"occurrencesAreUnique,omitempty"`
	Occurrences          *EventOccurrenceCreateManyWithoutEventInput `json:"occurrences,omitempty"`
}

type EventUpdateDataInput struct {
	Name                 *string                                     `json:"name,omitempty"`
	Description          *string                                     `json:"description,omitempty"`
	ShortDescription     *string                                     `json:"shortDescription,omitempty"`
	Link                 *string                                     `json:"link,omitempty"`
	ImageUrl             *string                                     `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string                                     `json:"nextOccurrenceDate,omitempty"`
	Price                *int32                                      `json:"price,omitempty"`
	Venue                *VenueUpdateOneWithoutEventsInput           `json:"venue,omitempty"`
	Category             *EventCategory                              `json:"category,omitempty"`
	Tags                 *string                                     `json:"tags,omitempty"`
	TicketUrl            *string                                     `json:"ticketUrl,omitempty"`
	Source               *string                                     `json:"source,omitempty"`
	WpFrId               *int32                                      `json:"wpFrId,omitempty"`
	WpEnId               *int32                                      `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool                                       `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string                                     `json:"importNotes,omitempty"`
	IsRecurring          *bool                                       `json:"isRecurring,omitempty"`
	RecurrencePattern    *string                                     `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool                                       `json:"occurrencesAreUnique,omitempty"`
	Occurrences          *EventOccurrenceUpdateManyWithoutEventInput `json:"occurrences,omitempty"`
}

type VenueCreateOneWithoutEventsInput struct {
	Create  *VenueCreateWithoutEventsInput `json:"create,omitempty"`
	Connect *VenueWhereUniqueInput         `json:"connect,omitempty"`
}

type EventOccurrenceUpdateInput struct {
	Name        *string                                        `json:"name,omitempty"`
	Description *string                                        `json:"description,omitempty"`
	ImageUrl    *string                                        `json:"imageUrl,omitempty"`
	StartDate   *string                                        `json:"startDate,omitempty"`
	EndDate     *string                                        `json:"endDate,omitempty"`
	Lat         *float64                                       `json:"lat,omitempty"`
	Long        *float64                                       `json:"long,omitempty"`
	Price       *int32                                         `json:"price,omitempty"`
	City        *City                                          `json:"city,omitempty"`
	TicketUrl   *string                                        `json:"ticketUrl,omitempty"`
	Event       *EventUpdateOneRequiredWithoutOccurrencesInput `json:"event,omitempty"`
}

type VenueCreateWithoutEventsInput struct {
	ID                *string `json:"id,omitempty"`
	NameFr            string  `json:"nameFr"`
	NameEn            string  `json:"nameEn"`
	Lat               float64 `json:"lat"`
	Long              float64 `json:"long"`
	City              City    `json:"city"`
	Address           *string `json:"address,omitempty"`
	Zip               *string `json:"zip,omitempty"`
	Country           *string `json:"country,omitempty"`
	Url               *string `json:"url,omitempty"`
	WpFrId            *int32  `json:"wpFrId,omitempty"`
	WpEnId            *int32  `json:"wpEnId,omitempty"`
	PossibleDuplicate *bool   `json:"possibleDuplicate,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EventOccurrenceCreateManyWithoutEventInput struct {
	Create  []EventOccurrenceCreateWithoutEventInput `json:"create,omitempty"`
	Connect []EventOccurrenceWhereUniqueInput        `json:"connect,omitempty"`
}

type SearchSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *SearchWhereInput              `json:"node,omitempty"`
	And                        []SearchSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []SearchSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []SearchSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EventOccurrenceCreateWithoutEventInput struct {
	ID          *string `json:"id,omitempty"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	ImageUrl    *string `json:"imageUrl,omitempty"`
	StartDate   string  `json:"startDate"`
	EndDate     *string `json:"endDate,omitempty"`
	Lat         float64 `json:"lat"`
	Long        float64 `json:"long"`
	Price       *int32  `json:"price,omitempty"`
	City        City    `json:"city"`
	TicketUrl   *string `json:"ticketUrl,omitempty"`
}

type EventOccurrenceSubscriptionWhereInput struct {
	MutationIn                 []MutationType                          `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                 `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                `json:"updatedFields_contains_some,omitempty"`
	Node                       *EventOccurrenceWhereInput              `json:"node,omitempty"`
	And                        []EventOccurrenceSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EventOccurrenceSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EventOccurrenceSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EventUpdateInput struct {
	Name                 *string                                     `json:"name,omitempty"`
	Description          *string                                     `json:"description,omitempty"`
	ShortDescription     *string                                     `json:"shortDescription,omitempty"`
	Link                 *string                                     `json:"link,omitempty"`
	ImageUrl             *string                                     `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string                                     `json:"nextOccurrenceDate,omitempty"`
	Price                *int32                                      `json:"price,omitempty"`
	Venue                *VenueUpdateOneWithoutEventsInput           `json:"venue,omitempty"`
	Category             *EventCategory                              `json:"category,omitempty"`
	Tags                 *string                                     `json:"tags,omitempty"`
	TicketUrl            *string                                     `json:"ticketUrl,omitempty"`
	Source               *string                                     `json:"source,omitempty"`
	WpFrId               *int32                                      `json:"wpFrId,omitempty"`
	WpEnId               *int32                                      `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool                                       `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string                                     `json:"importNotes,omitempty"`
	IsRecurring          *bool                                       `json:"isRecurring,omitempty"`
	RecurrencePattern    *string                                     `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool                                       `json:"occurrencesAreUnique,omitempty"`
	Occurrences          *EventOccurrenceUpdateManyWithoutEventInput `json:"occurrences,omitempty"`
}

type EventSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *EventWhereInput              `json:"node,omitempty"`
	And                        []EventSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EventSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EventSubscriptionWhereInput `json:"NOT,omitempty"`
}

type VenueUpdateOneWithoutEventsInput struct {
	Create     *VenueCreateWithoutEventsInput     `json:"create,omitempty"`
	Update     *VenueUpdateWithoutEventsDataInput `json:"update,omitempty"`
	Upsert     *VenueUpsertWithoutEventsInput     `json:"upsert,omitempty"`
	Delete     *bool                              `json:"delete,omitempty"`
	Disconnect *bool                              `json:"disconnect,omitempty"`
	Connect    *VenueWhereUniqueInput             `json:"connect,omitempty"`
}

type EventUpsertWithWhereUniqueWithoutVenueInput struct {
	Where  EventWhereUniqueInput            `json:"where"`
	Update EventUpdateWithoutVenueDataInput `json:"update"`
	Create EventCreateWithoutVenueInput     `json:"create"`
}

type VenueUpdateWithoutEventsDataInput struct {
	NameFr            *string  `json:"nameFr,omitempty"`
	NameEn            *string  `json:"nameEn,omitempty"`
	Lat               *float64 `json:"lat,omitempty"`
	Long              *float64 `json:"long,omitempty"`
	City              *City    `json:"city,omitempty"`
	Address           *string  `json:"address,omitempty"`
	Zip               *string  `json:"zip,omitempty"`
	Country           *string  `json:"country,omitempty"`
	Url               *string  `json:"url,omitempty"`
	WpFrId            *int32   `json:"wpFrId,omitempty"`
	WpEnId            *int32   `json:"wpEnId,omitempty"`
	PossibleDuplicate *bool    `json:"possibleDuplicate,omitempty"`
}

type EventWhereInput struct {
	ID                             *string                    `json:"id,omitempty"`
	IDNot                          *string                    `json:"id_not,omitempty"`
	IDIn                           []string                   `json:"id_in,omitempty"`
	IDNotIn                        []string                   `json:"id_not_in,omitempty"`
	IDLt                           *string                    `json:"id_lt,omitempty"`
	IDLte                          *string                    `json:"id_lte,omitempty"`
	IDGt                           *string                    `json:"id_gt,omitempty"`
	IDGte                          *string                    `json:"id_gte,omitempty"`
	IDContains                     *string                    `json:"id_contains,omitempty"`
	IDNotContains                  *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                    `json:"id_not_ends_with,omitempty"`
	Name                           *string                    `json:"name,omitempty"`
	NameNot                        *string                    `json:"name_not,omitempty"`
	NameIn                         []string                   `json:"name_in,omitempty"`
	NameNotIn                      []string                   `json:"name_not_in,omitempty"`
	NameLt                         *string                    `json:"name_lt,omitempty"`
	NameLte                        *string                    `json:"name_lte,omitempty"`
	NameGt                         *string                    `json:"name_gt,omitempty"`
	NameGte                        *string                    `json:"name_gte,omitempty"`
	NameContains                   *string                    `json:"name_contains,omitempty"`
	NameNotContains                *string                    `json:"name_not_contains,omitempty"`
	NameStartsWith                 *string                    `json:"name_starts_with,omitempty"`
	NameNotStartsWith              *string                    `json:"name_not_starts_with,omitempty"`
	NameEndsWith                   *string                    `json:"name_ends_with,omitempty"`
	NameNotEndsWith                *string                    `json:"name_not_ends_with,omitempty"`
	Description                    *string                    `json:"description,omitempty"`
	DescriptionNot                 *string                    `json:"description_not,omitempty"`
	DescriptionIn                  []string                   `json:"description_in,omitempty"`
	DescriptionNotIn               []string                   `json:"description_not_in,omitempty"`
	DescriptionLt                  *string                    `json:"description_lt,omitempty"`
	DescriptionLte                 *string                    `json:"description_lte,omitempty"`
	DescriptionGt                  *string                    `json:"description_gt,omitempty"`
	DescriptionGte                 *string                    `json:"description_gte,omitempty"`
	DescriptionContains            *string                    `json:"description_contains,omitempty"`
	DescriptionNotContains         *string                    `json:"description_not_contains,omitempty"`
	DescriptionStartsWith          *string                    `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith       *string                    `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith            *string                    `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith         *string                    `json:"description_not_ends_with,omitempty"`
	ShortDescription               *string                    `json:"shortDescription,omitempty"`
	ShortDescriptionNot            *string                    `json:"shortDescription_not,omitempty"`
	ShortDescriptionIn             []string                   `json:"shortDescription_in,omitempty"`
	ShortDescriptionNotIn          []string                   `json:"shortDescription_not_in,omitempty"`
	ShortDescriptionLt             *string                    `json:"shortDescription_lt,omitempty"`
	ShortDescriptionLte            *string                    `json:"shortDescription_lte,omitempty"`
	ShortDescriptionGt             *string                    `json:"shortDescription_gt,omitempty"`
	ShortDescriptionGte            *string                    `json:"shortDescription_gte,omitempty"`
	ShortDescriptionContains       *string                    `json:"shortDescription_contains,omitempty"`
	ShortDescriptionNotContains    *string                    `json:"shortDescription_not_contains,omitempty"`
	ShortDescriptionStartsWith     *string                    `json:"shortDescription_starts_with,omitempty"`
	ShortDescriptionNotStartsWith  *string                    `json:"shortDescription_not_starts_with,omitempty"`
	ShortDescriptionEndsWith       *string                    `json:"shortDescription_ends_with,omitempty"`
	ShortDescriptionNotEndsWith    *string                    `json:"shortDescription_not_ends_with,omitempty"`
	Link                           *string                    `json:"link,omitempty"`
	LinkNot                        *string                    `json:"link_not,omitempty"`
	LinkIn                         []string                   `json:"link_in,omitempty"`
	LinkNotIn                      []string                   `json:"link_not_in,omitempty"`
	LinkLt                         *string                    `json:"link_lt,omitempty"`
	LinkLte                        *string                    `json:"link_lte,omitempty"`
	LinkGt                         *string                    `json:"link_gt,omitempty"`
	LinkGte                        *string                    `json:"link_gte,omitempty"`
	LinkContains                   *string                    `json:"link_contains,omitempty"`
	LinkNotContains                *string                    `json:"link_not_contains,omitempty"`
	LinkStartsWith                 *string                    `json:"link_starts_with,omitempty"`
	LinkNotStartsWith              *string                    `json:"link_not_starts_with,omitempty"`
	LinkEndsWith                   *string                    `json:"link_ends_with,omitempty"`
	LinkNotEndsWith                *string                    `json:"link_not_ends_with,omitempty"`
	ImageUrl                       *string                    `json:"imageUrl,omitempty"`
	ImageUrlNot                    *string                    `json:"imageUrl_not,omitempty"`
	ImageUrlIn                     []string                   `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn                  []string                   `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt                     *string                    `json:"imageUrl_lt,omitempty"`
	ImageUrlLte                    *string                    `json:"imageUrl_lte,omitempty"`
	ImageUrlGt                     *string                    `json:"imageUrl_gt,omitempty"`
	ImageUrlGte                    *string                    `json:"imageUrl_gte,omitempty"`
	ImageUrlContains               *string                    `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains            *string                    `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith             *string                    `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith          *string                    `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith               *string                    `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith            *string                    `json:"imageUrl_not_ends_with,omitempty"`
	NextOccurrenceDate             *string                    `json:"nextOccurrenceDate,omitempty"`
	NextOccurrenceDateNot          *string                    `json:"nextOccurrenceDate_not,omitempty"`
	NextOccurrenceDateIn           []string                   `json:"nextOccurrenceDate_in,omitempty"`
	NextOccurrenceDateNotIn        []string                   `json:"nextOccurrenceDate_not_in,omitempty"`
	NextOccurrenceDateLt           *string                    `json:"nextOccurrenceDate_lt,omitempty"`
	NextOccurrenceDateLte          *string                    `json:"nextOccurrenceDate_lte,omitempty"`
	NextOccurrenceDateGt           *string                    `json:"nextOccurrenceDate_gt,omitempty"`
	NextOccurrenceDateGte          *string                    `json:"nextOccurrenceDate_gte,omitempty"`
	Price                          *int32                     `json:"price,omitempty"`
	PriceNot                       *int32                     `json:"price_not,omitempty"`
	PriceIn                        []int32                    `json:"price_in,omitempty"`
	PriceNotIn                     []int32                    `json:"price_not_in,omitempty"`
	PriceLt                        *int32                     `json:"price_lt,omitempty"`
	PriceLte                       *int32                     `json:"price_lte,omitempty"`
	PriceGt                        *int32                     `json:"price_gt,omitempty"`
	PriceGte                       *int32                     `json:"price_gte,omitempty"`
	Venue                          *VenueWhereInput           `json:"venue,omitempty"`
	Category                       *EventCategory             `json:"category,omitempty"`
	CategoryNot                    *EventCategory             `json:"category_not,omitempty"`
	CategoryIn                     []EventCategory            `json:"category_in,omitempty"`
	CategoryNotIn                  []EventCategory            `json:"category_not_in,omitempty"`
	Tags                           *string                    `json:"tags,omitempty"`
	TagsNot                        *string                    `json:"tags_not,omitempty"`
	TagsIn                         []string                   `json:"tags_in,omitempty"`
	TagsNotIn                      []string                   `json:"tags_not_in,omitempty"`
	TagsLt                         *string                    `json:"tags_lt,omitempty"`
	TagsLte                        *string                    `json:"tags_lte,omitempty"`
	TagsGt                         *string                    `json:"tags_gt,omitempty"`
	TagsGte                        *string                    `json:"tags_gte,omitempty"`
	TagsContains                   *string                    `json:"tags_contains,omitempty"`
	TagsNotContains                *string                    `json:"tags_not_contains,omitempty"`
	TagsStartsWith                 *string                    `json:"tags_starts_with,omitempty"`
	TagsNotStartsWith              *string                    `json:"tags_not_starts_with,omitempty"`
	TagsEndsWith                   *string                    `json:"tags_ends_with,omitempty"`
	TagsNotEndsWith                *string                    `json:"tags_not_ends_with,omitempty"`
	TicketUrl                      *string                    `json:"ticketUrl,omitempty"`
	TicketUrlNot                   *string                    `json:"ticketUrl_not,omitempty"`
	TicketUrlIn                    []string                   `json:"ticketUrl_in,omitempty"`
	TicketUrlNotIn                 []string                   `json:"ticketUrl_not_in,omitempty"`
	TicketUrlLt                    *string                    `json:"ticketUrl_lt,omitempty"`
	TicketUrlLte                   *string                    `json:"ticketUrl_lte,omitempty"`
	TicketUrlGt                    *string                    `json:"ticketUrl_gt,omitempty"`
	TicketUrlGte                   *string                    `json:"ticketUrl_gte,omitempty"`
	TicketUrlContains              *string                    `json:"ticketUrl_contains,omitempty"`
	TicketUrlNotContains           *string                    `json:"ticketUrl_not_contains,omitempty"`
	TicketUrlStartsWith            *string                    `json:"ticketUrl_starts_with,omitempty"`
	TicketUrlNotStartsWith         *string                    `json:"ticketUrl_not_starts_with,omitempty"`
	TicketUrlEndsWith              *string                    `json:"ticketUrl_ends_with,omitempty"`
	TicketUrlNotEndsWith           *string                    `json:"ticketUrl_not_ends_with,omitempty"`
	Source                         *string                    `json:"source,omitempty"`
	SourceNot                      *string                    `json:"source_not,omitempty"`
	SourceIn                       []string                   `json:"source_in,omitempty"`
	SourceNotIn                    []string                   `json:"source_not_in,omitempty"`
	SourceLt                       *string                    `json:"source_lt,omitempty"`
	SourceLte                      *string                    `json:"source_lte,omitempty"`
	SourceGt                       *string                    `json:"source_gt,omitempty"`
	SourceGte                      *string                    `json:"source_gte,omitempty"`
	SourceContains                 *string                    `json:"source_contains,omitempty"`
	SourceNotContains              *string                    `json:"source_not_contains,omitempty"`
	SourceStartsWith               *string                    `json:"source_starts_with,omitempty"`
	SourceNotStartsWith            *string                    `json:"source_not_starts_with,omitempty"`
	SourceEndsWith                 *string                    `json:"source_ends_with,omitempty"`
	SourceNotEndsWith              *string                    `json:"source_not_ends_with,omitempty"`
	WpFrId                         *int32                     `json:"wpFrId,omitempty"`
	WpFrIdNot                      *int32                     `json:"wpFrId_not,omitempty"`
	WpFrIdIn                       []int32                    `json:"wpFrId_in,omitempty"`
	WpFrIdNotIn                    []int32                    `json:"wpFrId_not_in,omitempty"`
	WpFrIdLt                       *int32                     `json:"wpFrId_lt,omitempty"`
	WpFrIdLte                      *int32                     `json:"wpFrId_lte,omitempty"`
	WpFrIdGt                       *int32                     `json:"wpFrId_gt,omitempty"`
	WpFrIdGte                      *int32                     `json:"wpFrId_gte,omitempty"`
	WpEnId                         *int32                     `json:"wpEnId,omitempty"`
	WpEnIdNot                      *int32                     `json:"wpEnId_not,omitempty"`
	WpEnIdIn                       []int32                    `json:"wpEnId_in,omitempty"`
	WpEnIdNotIn                    []int32                    `json:"wpEnId_not_in,omitempty"`
	WpEnIdLt                       *int32                     `json:"wpEnId_lt,omitempty"`
	WpEnIdLte                      *int32                     `json:"wpEnId_lte,omitempty"`
	WpEnIdGt                       *int32                     `json:"wpEnId_gt,omitempty"`
	WpEnIdGte                      *int32                     `json:"wpEnId_gte,omitempty"`
	PossibleDuplicate              *bool                      `json:"possibleDuplicate,omitempty"`
	PossibleDuplicateNot           *bool                      `json:"possibleDuplicate_not,omitempty"`
	ImportNotes                    *string                    `json:"importNotes,omitempty"`
	ImportNotesNot                 *string                    `json:"importNotes_not,omitempty"`
	ImportNotesIn                  []string                   `json:"importNotes_in,omitempty"`
	ImportNotesNotIn               []string                   `json:"importNotes_not_in,omitempty"`
	ImportNotesLt                  *string                    `json:"importNotes_lt,omitempty"`
	ImportNotesLte                 *string                    `json:"importNotes_lte,omitempty"`
	ImportNotesGt                  *string                    `json:"importNotes_gt,omitempty"`
	ImportNotesGte                 *string                    `json:"importNotes_gte,omitempty"`
	ImportNotesContains            *string                    `json:"importNotes_contains,omitempty"`
	ImportNotesNotContains         *string                    `json:"importNotes_not_contains,omitempty"`
	ImportNotesStartsWith          *string                    `json:"importNotes_starts_with,omitempty"`
	ImportNotesNotStartsWith       *string                    `json:"importNotes_not_starts_with,omitempty"`
	ImportNotesEndsWith            *string                    `json:"importNotes_ends_with,omitempty"`
	ImportNotesNotEndsWith         *string                    `json:"importNotes_not_ends_with,omitempty"`
	IsRecurring                    *bool                      `json:"isRecurring,omitempty"`
	IsRecurringNot                 *bool                      `json:"isRecurring_not,omitempty"`
	RecurrencePattern              *string                    `json:"recurrencePattern,omitempty"`
	RecurrencePatternNot           *string                    `json:"recurrencePattern_not,omitempty"`
	RecurrencePatternIn            []string                   `json:"recurrencePattern_in,omitempty"`
	RecurrencePatternNotIn         []string                   `json:"recurrencePattern_not_in,omitempty"`
	RecurrencePatternLt            *string                    `json:"recurrencePattern_lt,omitempty"`
	RecurrencePatternLte           *string                    `json:"recurrencePattern_lte,omitempty"`
	RecurrencePatternGt            *string                    `json:"recurrencePattern_gt,omitempty"`
	RecurrencePatternGte           *string                    `json:"recurrencePattern_gte,omitempty"`
	RecurrencePatternContains      *string                    `json:"recurrencePattern_contains,omitempty"`
	RecurrencePatternNotContains   *string                    `json:"recurrencePattern_not_contains,omitempty"`
	RecurrencePatternStartsWith    *string                    `json:"recurrencePattern_starts_with,omitempty"`
	RecurrencePatternNotStartsWith *string                    `json:"recurrencePattern_not_starts_with,omitempty"`
	RecurrencePatternEndsWith      *string                    `json:"recurrencePattern_ends_with,omitempty"`
	RecurrencePatternNotEndsWith   *string                    `json:"recurrencePattern_not_ends_with,omitempty"`
	OccurrencesAreUnique           *bool                      `json:"occurrencesAreUnique,omitempty"`
	OccurrencesAreUniqueNot        *bool                      `json:"occurrencesAreUnique_not,omitempty"`
	OccurrencesEvery               *EventOccurrenceWhereInput `json:"occurrences_every,omitempty"`
	OccurrencesSome                *EventOccurrenceWhereInput `json:"occurrences_some,omitempty"`
	OccurrencesNone                *EventOccurrenceWhereInput `json:"occurrences_none,omitempty"`
	CreatedAt                      *string                    `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                    `json:"updatedAt_gte,omitempty"`
	And                            []EventWhereInput          `json:"AND,omitempty"`
	Or                             []EventWhereInput          `json:"OR,omitempty"`
	Not                            []EventWhereInput          `json:"NOT,omitempty"`
}

type VenueUpsertWithoutEventsInput struct {
	Update VenueUpdateWithoutEventsDataInput `json:"update"`
	Create VenueCreateWithoutEventsInput     `json:"create"`
}

type RequestedCityWhereInput struct {
	ID                *string                   `json:"id,omitempty"`
	IDNot             *string                   `json:"id_not,omitempty"`
	IDIn              []string                  `json:"id_in,omitempty"`
	IDNotIn           []string                  `json:"id_not_in,omitempty"`
	IDLt              *string                   `json:"id_lt,omitempty"`
	IDLte             *string                   `json:"id_lte,omitempty"`
	IDGt              *string                   `json:"id_gt,omitempty"`
	IDGte             *string                   `json:"id_gte,omitempty"`
	IDContains        *string                   `json:"id_contains,omitempty"`
	IDNotContains     *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                   `json:"id_not_ends_with,omitempty"`
	City              *string                   `json:"city,omitempty"`
	CityNot           *string                   `json:"city_not,omitempty"`
	CityIn            []string                  `json:"city_in,omitempty"`
	CityNotIn         []string                  `json:"city_not_in,omitempty"`
	CityLt            *string                   `json:"city_lt,omitempty"`
	CityLte           *string                   `json:"city_lte,omitempty"`
	CityGt            *string                   `json:"city_gt,omitempty"`
	CityGte           *string                   `json:"city_gte,omitempty"`
	CityContains      *string                   `json:"city_contains,omitempty"`
	CityNotContains   *string                   `json:"city_not_contains,omitempty"`
	CityStartsWith    *string                   `json:"city_starts_with,omitempty"`
	CityNotStartsWith *string                   `json:"city_not_starts_with,omitempty"`
	CityEndsWith      *string                   `json:"city_ends_with,omitempty"`
	CityNotEndsWith   *string                   `json:"city_not_ends_with,omitempty"`
	User              *UserWhereInput           `json:"user,omitempty"`
	SendEmail         *bool                     `json:"sendEmail,omitempty"`
	SendEmailNot      *bool                     `json:"sendEmail_not,omitempty"`
	And               []RequestedCityWhereInput `json:"AND,omitempty"`
	Or                []RequestedCityWhereInput `json:"OR,omitempty"`
	Not               []RequestedCityWhereInput `json:"NOT,omitempty"`
}

type EventOccurrenceUpdateManyWithoutEventInput struct {
	Create     []EventOccurrenceCreateWithoutEventInput                `json:"create,omitempty"`
	Delete     []EventOccurrenceWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []EventOccurrenceWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []EventOccurrenceWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []EventOccurrenceWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []EventOccurrenceUpdateWithWhereUniqueWithoutEventInput `json:"update,omitempty"`
	Upsert     []EventOccurrenceUpsertWithWhereUniqueWithoutEventInput `json:"upsert,omitempty"`
	DeleteMany []EventOccurrenceScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []EventOccurrenceUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type EventUpdateWithWhereUniqueWithoutVenueInput struct {
	Where EventWhereUniqueInput            `json:"where"`
	Data  EventUpdateWithoutVenueDataInput `json:"data"`
}

type EventOccurrenceUpdateWithWhereUniqueWithoutEventInput struct {
	Where EventOccurrenceWhereUniqueInput            `json:"where"`
	Data  EventOccurrenceUpdateWithoutEventDataInput `json:"data"`
}

type VenueUpdateInput struct {
	NameFr            *string                           `json:"nameFr,omitempty"`
	NameEn            *string                           `json:"nameEn,omitempty"`
	Lat               *float64                          `json:"lat,omitempty"`
	Long              *float64                          `json:"long,omitempty"`
	City              *City                             `json:"city,omitempty"`
	Address           *string                           `json:"address,omitempty"`
	Zip               *string                           `json:"zip,omitempty"`
	Country           *string                           `json:"country,omitempty"`
	Url               *string                           `json:"url,omitempty"`
	WpFrId            *int32                            `json:"wpFrId,omitempty"`
	WpEnId            *int32                            `json:"wpEnId,omitempty"`
	Events            *EventUpdateManyWithoutVenueInput `json:"events,omitempty"`
	PossibleDuplicate *bool                             `json:"possibleDuplicate,omitempty"`
}

type EventOccurrenceUpdateWithoutEventDataInput struct {
	Name        *string  `json:"name,omitempty"`
	Description *string  `json:"description,omitempty"`
	ImageUrl    *string  `json:"imageUrl,omitempty"`
	StartDate   *string  `json:"startDate,omitempty"`
	EndDate     *string  `json:"endDate,omitempty"`
	Lat         *float64 `json:"lat,omitempty"`
	Long        *float64 `json:"long,omitempty"`
	Price       *int32   `json:"price,omitempty"`
	City        *City    `json:"city,omitempty"`
	TicketUrl   *string  `json:"ticketUrl,omitempty"`
}

type SearchWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EventOccurrenceUpsertWithWhereUniqueWithoutEventInput struct {
	Where  EventOccurrenceWhereUniqueInput            `json:"where"`
	Update EventOccurrenceUpdateWithoutEventDataInput `json:"update"`
	Create EventOccurrenceCreateWithoutEventInput     `json:"create"`
}

type SearchWhereInput struct {
	ID                    *string                    `json:"id,omitempty"`
	IDNot                 *string                    `json:"id_not,omitempty"`
	IDIn                  []string                   `json:"id_in,omitempty"`
	IDNotIn               []string                   `json:"id_not_in,omitempty"`
	IDLt                  *string                    `json:"id_lt,omitempty"`
	IDLte                 *string                    `json:"id_lte,omitempty"`
	IDGt                  *string                    `json:"id_gt,omitempty"`
	IDGte                 *string                    `json:"id_gte,omitempty"`
	IDContains            *string                    `json:"id_contains,omitempty"`
	IDNotContains         *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                    `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string                    `json:"createdAt,omitempty"`
	CreatedAtNot          *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                    `json:"createdAt_gte,omitempty"`
	City                  *City                      `json:"city,omitempty"`
	CityNot               *City                      `json:"city_not,omitempty"`
	CityIn                []City                     `json:"city_in,omitempty"`
	CityNotIn             []City                     `json:"city_not_in,omitempty"`
	StartDate             *string                    `json:"startDate,omitempty"`
	StartDateNot          *string                    `json:"startDate_not,omitempty"`
	StartDateIn           []string                   `json:"startDate_in,omitempty"`
	StartDateNotIn        []string                   `json:"startDate_not_in,omitempty"`
	StartDateLt           *string                    `json:"startDate_lt,omitempty"`
	StartDateLte          *string                    `json:"startDate_lte,omitempty"`
	StartDateGt           *string                    `json:"startDate_gt,omitempty"`
	StartDateGte          *string                    `json:"startDate_gte,omitempty"`
	EndDate               *string                    `json:"endDate,omitempty"`
	EndDateNot            *string                    `json:"endDate_not,omitempty"`
	EndDateIn             []string                   `json:"endDate_in,omitempty"`
	EndDateNotIn          []string                   `json:"endDate_not_in,omitempty"`
	EndDateLt             *string                    `json:"endDate_lt,omitempty"`
	EndDateLte            *string                    `json:"endDate_lte,omitempty"`
	EndDateGt             *string                    `json:"endDate_gt,omitempty"`
	EndDateGte            *string                    `json:"endDate_gte,omitempty"`
	Info                  *string                    `json:"info,omitempty"`
	InfoNot               *string                    `json:"info_not,omitempty"`
	InfoIn                []string                   `json:"info_in,omitempty"`
	InfoNotIn             []string                   `json:"info_not_in,omitempty"`
	InfoLt                *string                    `json:"info_lt,omitempty"`
	InfoLte               *string                    `json:"info_lte,omitempty"`
	InfoGt                *string                    `json:"info_gt,omitempty"`
	InfoGte               *string                    `json:"info_gte,omitempty"`
	InfoContains          *string                    `json:"info_contains,omitempty"`
	InfoNotContains       *string                    `json:"info_not_contains,omitempty"`
	InfoStartsWith        *string                    `json:"info_starts_with,omitempty"`
	InfoNotStartsWith     *string                    `json:"info_not_starts_with,omitempty"`
	InfoEndsWith          *string                    `json:"info_ends_with,omitempty"`
	InfoNotEndsWith       *string                    `json:"info_not_ends_with,omitempty"`
	Suggested             *int32                     `json:"suggested,omitempty"`
	SuggestedNot          *int32                     `json:"suggested_not,omitempty"`
	SuggestedIn           []int32                    `json:"suggested_in,omitempty"`
	SuggestedNotIn        []int32                    `json:"suggested_not_in,omitempty"`
	SuggestedLt           *int32                     `json:"suggested_lt,omitempty"`
	SuggestedLte          *int32                     `json:"suggested_lte,omitempty"`
	SuggestedGt           *int32                     `json:"suggested_gt,omitempty"`
	SuggestedGte          *int32                     `json:"suggested_gte,omitempty"`
	User                  *UserWhereInput            `json:"user,omitempty"`
	EventsEvery           *EventWhereInput           `json:"events_every,omitempty"`
	EventsSome            *EventWhereInput           `json:"events_some,omitempty"`
	EventsNone            *EventWhereInput           `json:"events_none,omitempty"`
	EventOccurrencesEvery *EventOccurrenceWhereInput `json:"eventOccurrences_every,omitempty"`
	EventOccurrencesSome  *EventOccurrenceWhereInput `json:"eventOccurrences_some,omitempty"`
	EventOccurrencesNone  *EventOccurrenceWhereInput `json:"eventOccurrences_none,omitempty"`
	And                   []SearchWhereInput         `json:"AND,omitempty"`
	Or                    []SearchWhereInput         `json:"OR,omitempty"`
	Not                   []SearchWhereInput         `json:"NOT,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type UserUpdateManyMutationInput struct {
	Facebookid             *string                     `json:"facebookid,omitempty"`
	Fname                  *string                     `json:"fname,omitempty"`
	Lname                  *string                     `json:"lname,omitempty"`
	Picture                *string                     `json:"picture,omitempty"`
	Email                  *string                     `json:"email,omitempty"`
	Password               *string                     `json:"password,omitempty"`
	Sex                    *Sex                        `json:"sex,omitempty"`
	Age                    *int32                      `json:"age,omitempty"`
	City                   *City                       `json:"city,omitempty"`
	Permissions            *UserUpdatepermissionsInput `json:"permissions,omitempty"`
	Relationship           *Relationship               `json:"relationship,omitempty"`
	LastInteraction        *string                     `json:"lastInteraction,omitempty"`
	MessengerNotifications *Notification               `json:"messengerNotifications,omitempty"`
}

type EventOccurrenceUpdateManyWithWhereNestedInput struct {
	Where EventOccurrenceScalarWhereInput    `json:"where"`
	Data  EventOccurrenceUpdateManyDataInput `json:"data"`
}

type SearchUpdateManyMutationInput struct {
	City      *City   `json:"city,omitempty"`
	StartDate *string `json:"startDate,omitempty"`
	EndDate   *string `json:"endDate,omitempty"`
	Info      *string `json:"info,omitempty"`
	Suggested *int32  `json:"suggested,omitempty"`
}

type EventOccurrenceUpdateManyDataInput struct {
	Name        *string  `json:"name,omitempty"`
	Description *string  `json:"description,omitempty"`
	ImageUrl    *string  `json:"imageUrl,omitempty"`
	StartDate   *string  `json:"startDate,omitempty"`
	EndDate     *string  `json:"endDate,omitempty"`
	Lat         *float64 `json:"lat,omitempty"`
	Long        *float64 `json:"long,omitempty"`
	Price       *int32   `json:"price,omitempty"`
	City        *City    `json:"city,omitempty"`
	TicketUrl   *string  `json:"ticketUrl,omitempty"`
}

type EventOccurrenceUpsertWithWhereUniqueNestedInput struct {
	Where  EventOccurrenceWhereUniqueInput `json:"where"`
	Update EventOccurrenceUpdateDataInput  `json:"update"`
	Create EventOccurrenceCreateInput      `json:"create"`
}

type EventUpdateManyMutationInput struct {
	Name                 *string        `json:"name,omitempty"`
	Description          *string        `json:"description,omitempty"`
	ShortDescription     *string        `json:"shortDescription,omitempty"`
	Link                 *string        `json:"link,omitempty"`
	ImageUrl             *string        `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string        `json:"nextOccurrenceDate,omitempty"`
	Price                *int32         `json:"price,omitempty"`
	Category             *EventCategory `json:"category,omitempty"`
	Tags                 *string        `json:"tags,omitempty"`
	TicketUrl            *string        `json:"ticketUrl,omitempty"`
	Source               *string        `json:"source,omitempty"`
	WpFrId               *int32         `json:"wpFrId,omitempty"`
	WpEnId               *int32         `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool          `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string        `json:"importNotes,omitempty"`
	IsRecurring          *bool          `json:"isRecurring,omitempty"`
	RecurrencePattern    *string        `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool          `json:"occurrencesAreUnique,omitempty"`
}

type EventOccurrenceUpdateWithWhereUniqueNestedInput struct {
	Where EventOccurrenceWhereUniqueInput `json:"where"`
	Data  EventOccurrenceUpdateDataInput  `json:"data"`
}

type EventUpdateManyDataInput struct {
	Name                 *string        `json:"name,omitempty"`
	Description          *string        `json:"description,omitempty"`
	ShortDescription     *string        `json:"shortDescription,omitempty"`
	Link                 *string        `json:"link,omitempty"`
	ImageUrl             *string        `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string        `json:"nextOccurrenceDate,omitempty"`
	Price                *int32         `json:"price,omitempty"`
	Category             *EventCategory `json:"category,omitempty"`
	Tags                 *string        `json:"tags,omitempty"`
	TicketUrl            *string        `json:"ticketUrl,omitempty"`
	Source               *string        `json:"source,omitempty"`
	WpFrId               *int32         `json:"wpFrId,omitempty"`
	WpEnId               *int32         `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool          `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string        `json:"importNotes,omitempty"`
	IsRecurring          *bool          `json:"isRecurring,omitempty"`
	RecurrencePattern    *string        `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool          `json:"occurrencesAreUnique,omitempty"`
}

type VenueWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	NameFr *string `json:"nameFr,omitempty"`
	NameEn *string `json:"nameEn,omitempty"`
}

type EventUpdateManyWithWhereNestedInput struct {
	Where EventScalarWhereInput    `json:"where"`
	Data  EventUpdateManyDataInput `json:"data"`
}

type EventOccurrenceCreateManyInput struct {
	Create  []EventOccurrenceCreateInput      `json:"create,omitempty"`
	Connect []EventOccurrenceWhereUniqueInput `json:"connect,omitempty"`
}

type EventOccurrenceCreateInput struct {
	ID          *string                               `json:"id,omitempty"`
	Name        string                                `json:"name"`
	Description *string                               `json:"description,omitempty"`
	ImageUrl    *string                               `json:"imageUrl,omitempty"`
	StartDate   string                                `json:"startDate"`
	EndDate     *string                               `json:"endDate,omitempty"`
	Lat         float64                               `json:"lat"`
	Long        float64                               `json:"long"`
	Price       *int32                                `json:"price,omitempty"`
	City        City                                  `json:"city"`
	TicketUrl   *string                               `json:"ticketUrl,omitempty"`
	Event       EventCreateOneWithoutOccurrencesInput `json:"event"`
}

type RequestedCityUpdateManyMutationInput struct {
	City      *string `json:"city,omitempty"`
	SendEmail *bool   `json:"sendEmail,omitempty"`
}

type EventCreateOneWithoutOccurrencesInput struct {
	Create  *EventCreateWithoutOccurrencesInput `json:"create,omitempty"`
	Connect *EventWhereUniqueInput              `json:"connect,omitempty"`
}

type VenueSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *VenueWhereInput              `json:"node,omitempty"`
	And                        []VenueSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []VenueSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []VenueSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EventScalarWhereInput struct {
	ID                             *string                 `json:"id,omitempty"`
	IDNot                          *string                 `json:"id_not,omitempty"`
	IDIn                           []string                `json:"id_in,omitempty"`
	IDNotIn                        []string                `json:"id_not_in,omitempty"`
	IDLt                           *string                 `json:"id_lt,omitempty"`
	IDLte                          *string                 `json:"id_lte,omitempty"`
	IDGt                           *string                 `json:"id_gt,omitempty"`
	IDGte                          *string                 `json:"id_gte,omitempty"`
	IDContains                     *string                 `json:"id_contains,omitempty"`
	IDNotContains                  *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                 `json:"id_not_ends_with,omitempty"`
	Name                           *string                 `json:"name,omitempty"`
	NameNot                        *string                 `json:"name_not,omitempty"`
	NameIn                         []string                `json:"name_in,omitempty"`
	NameNotIn                      []string                `json:"name_not_in,omitempty"`
	NameLt                         *string                 `json:"name_lt,omitempty"`
	NameLte                        *string                 `json:"name_lte,omitempty"`
	NameGt                         *string                 `json:"name_gt,omitempty"`
	NameGte                        *string                 `json:"name_gte,omitempty"`
	NameContains                   *string                 `json:"name_contains,omitempty"`
	NameNotContains                *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith                 *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith              *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith                   *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith                *string                 `json:"name_not_ends_with,omitempty"`
	Description                    *string                 `json:"description,omitempty"`
	DescriptionNot                 *string                 `json:"description_not,omitempty"`
	DescriptionIn                  []string                `json:"description_in,omitempty"`
	DescriptionNotIn               []string                `json:"description_not_in,omitempty"`
	DescriptionLt                  *string                 `json:"description_lt,omitempty"`
	DescriptionLte                 *string                 `json:"description_lte,omitempty"`
	DescriptionGt                  *string                 `json:"description_gt,omitempty"`
	DescriptionGte                 *string                 `json:"description_gte,omitempty"`
	DescriptionContains            *string                 `json:"description_contains,omitempty"`
	DescriptionNotContains         *string                 `json:"description_not_contains,omitempty"`
	DescriptionStartsWith          *string                 `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith       *string                 `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith            *string                 `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith         *string                 `json:"description_not_ends_with,omitempty"`
	ShortDescription               *string                 `json:"shortDescription,omitempty"`
	ShortDescriptionNot            *string                 `json:"shortDescription_not,omitempty"`
	ShortDescriptionIn             []string                `json:"shortDescription_in,omitempty"`
	ShortDescriptionNotIn          []string                `json:"shortDescription_not_in,omitempty"`
	ShortDescriptionLt             *string                 `json:"shortDescription_lt,omitempty"`
	ShortDescriptionLte            *string                 `json:"shortDescription_lte,omitempty"`
	ShortDescriptionGt             *string                 `json:"shortDescription_gt,omitempty"`
	ShortDescriptionGte            *string                 `json:"shortDescription_gte,omitempty"`
	ShortDescriptionContains       *string                 `json:"shortDescription_contains,omitempty"`
	ShortDescriptionNotContains    *string                 `json:"shortDescription_not_contains,omitempty"`
	ShortDescriptionStartsWith     *string                 `json:"shortDescription_starts_with,omitempty"`
	ShortDescriptionNotStartsWith  *string                 `json:"shortDescription_not_starts_with,omitempty"`
	ShortDescriptionEndsWith       *string                 `json:"shortDescription_ends_with,omitempty"`
	ShortDescriptionNotEndsWith    *string                 `json:"shortDescription_not_ends_with,omitempty"`
	Link                           *string                 `json:"link,omitempty"`
	LinkNot                        *string                 `json:"link_not,omitempty"`
	LinkIn                         []string                `json:"link_in,omitempty"`
	LinkNotIn                      []string                `json:"link_not_in,omitempty"`
	LinkLt                         *string                 `json:"link_lt,omitempty"`
	LinkLte                        *string                 `json:"link_lte,omitempty"`
	LinkGt                         *string                 `json:"link_gt,omitempty"`
	LinkGte                        *string                 `json:"link_gte,omitempty"`
	LinkContains                   *string                 `json:"link_contains,omitempty"`
	LinkNotContains                *string                 `json:"link_not_contains,omitempty"`
	LinkStartsWith                 *string                 `json:"link_starts_with,omitempty"`
	LinkNotStartsWith              *string                 `json:"link_not_starts_with,omitempty"`
	LinkEndsWith                   *string                 `json:"link_ends_with,omitempty"`
	LinkNotEndsWith                *string                 `json:"link_not_ends_with,omitempty"`
	ImageUrl                       *string                 `json:"imageUrl,omitempty"`
	ImageUrlNot                    *string                 `json:"imageUrl_not,omitempty"`
	ImageUrlIn                     []string                `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn                  []string                `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt                     *string                 `json:"imageUrl_lt,omitempty"`
	ImageUrlLte                    *string                 `json:"imageUrl_lte,omitempty"`
	ImageUrlGt                     *string                 `json:"imageUrl_gt,omitempty"`
	ImageUrlGte                    *string                 `json:"imageUrl_gte,omitempty"`
	ImageUrlContains               *string                 `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains            *string                 `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith             *string                 `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith          *string                 `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith               *string                 `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith            *string                 `json:"imageUrl_not_ends_with,omitempty"`
	NextOccurrenceDate             *string                 `json:"nextOccurrenceDate,omitempty"`
	NextOccurrenceDateNot          *string                 `json:"nextOccurrenceDate_not,omitempty"`
	NextOccurrenceDateIn           []string                `json:"nextOccurrenceDate_in,omitempty"`
	NextOccurrenceDateNotIn        []string                `json:"nextOccurrenceDate_not_in,omitempty"`
	NextOccurrenceDateLt           *string                 `json:"nextOccurrenceDate_lt,omitempty"`
	NextOccurrenceDateLte          *string                 `json:"nextOccurrenceDate_lte,omitempty"`
	NextOccurrenceDateGt           *string                 `json:"nextOccurrenceDate_gt,omitempty"`
	NextOccurrenceDateGte          *string                 `json:"nextOccurrenceDate_gte,omitempty"`
	Price                          *int32                  `json:"price,omitempty"`
	PriceNot                       *int32                  `json:"price_not,omitempty"`
	PriceIn                        []int32                 `json:"price_in,omitempty"`
	PriceNotIn                     []int32                 `json:"price_not_in,omitempty"`
	PriceLt                        *int32                  `json:"price_lt,omitempty"`
	PriceLte                       *int32                  `json:"price_lte,omitempty"`
	PriceGt                        *int32                  `json:"price_gt,omitempty"`
	PriceGte                       *int32                  `json:"price_gte,omitempty"`
	Category                       *EventCategory          `json:"category,omitempty"`
	CategoryNot                    *EventCategory          `json:"category_not,omitempty"`
	CategoryIn                     []EventCategory         `json:"category_in,omitempty"`
	CategoryNotIn                  []EventCategory         `json:"category_not_in,omitempty"`
	Tags                           *string                 `json:"tags,omitempty"`
	TagsNot                        *string                 `json:"tags_not,omitempty"`
	TagsIn                         []string                `json:"tags_in,omitempty"`
	TagsNotIn                      []string                `json:"tags_not_in,omitempty"`
	TagsLt                         *string                 `json:"tags_lt,omitempty"`
	TagsLte                        *string                 `json:"tags_lte,omitempty"`
	TagsGt                         *string                 `json:"tags_gt,omitempty"`
	TagsGte                        *string                 `json:"tags_gte,omitempty"`
	TagsContains                   *string                 `json:"tags_contains,omitempty"`
	TagsNotContains                *string                 `json:"tags_not_contains,omitempty"`
	TagsStartsWith                 *string                 `json:"tags_starts_with,omitempty"`
	TagsNotStartsWith              *string                 `json:"tags_not_starts_with,omitempty"`
	TagsEndsWith                   *string                 `json:"tags_ends_with,omitempty"`
	TagsNotEndsWith                *string                 `json:"tags_not_ends_with,omitempty"`
	TicketUrl                      *string                 `json:"ticketUrl,omitempty"`
	TicketUrlNot                   *string                 `json:"ticketUrl_not,omitempty"`
	TicketUrlIn                    []string                `json:"ticketUrl_in,omitempty"`
	TicketUrlNotIn                 []string                `json:"ticketUrl_not_in,omitempty"`
	TicketUrlLt                    *string                 `json:"ticketUrl_lt,omitempty"`
	TicketUrlLte                   *string                 `json:"ticketUrl_lte,omitempty"`
	TicketUrlGt                    *string                 `json:"ticketUrl_gt,omitempty"`
	TicketUrlGte                   *string                 `json:"ticketUrl_gte,omitempty"`
	TicketUrlContains              *string                 `json:"ticketUrl_contains,omitempty"`
	TicketUrlNotContains           *string                 `json:"ticketUrl_not_contains,omitempty"`
	TicketUrlStartsWith            *string                 `json:"ticketUrl_starts_with,omitempty"`
	TicketUrlNotStartsWith         *string                 `json:"ticketUrl_not_starts_with,omitempty"`
	TicketUrlEndsWith              *string                 `json:"ticketUrl_ends_with,omitempty"`
	TicketUrlNotEndsWith           *string                 `json:"ticketUrl_not_ends_with,omitempty"`
	Source                         *string                 `json:"source,omitempty"`
	SourceNot                      *string                 `json:"source_not,omitempty"`
	SourceIn                       []string                `json:"source_in,omitempty"`
	SourceNotIn                    []string                `json:"source_not_in,omitempty"`
	SourceLt                       *string                 `json:"source_lt,omitempty"`
	SourceLte                      *string                 `json:"source_lte,omitempty"`
	SourceGt                       *string                 `json:"source_gt,omitempty"`
	SourceGte                      *string                 `json:"source_gte,omitempty"`
	SourceContains                 *string                 `json:"source_contains,omitempty"`
	SourceNotContains              *string                 `json:"source_not_contains,omitempty"`
	SourceStartsWith               *string                 `json:"source_starts_with,omitempty"`
	SourceNotStartsWith            *string                 `json:"source_not_starts_with,omitempty"`
	SourceEndsWith                 *string                 `json:"source_ends_with,omitempty"`
	SourceNotEndsWith              *string                 `json:"source_not_ends_with,omitempty"`
	WpFrId                         *int32                  `json:"wpFrId,omitempty"`
	WpFrIdNot                      *int32                  `json:"wpFrId_not,omitempty"`
	WpFrIdIn                       []int32                 `json:"wpFrId_in,omitempty"`
	WpFrIdNotIn                    []int32                 `json:"wpFrId_not_in,omitempty"`
	WpFrIdLt                       *int32                  `json:"wpFrId_lt,omitempty"`
	WpFrIdLte                      *int32                  `json:"wpFrId_lte,omitempty"`
	WpFrIdGt                       *int32                  `json:"wpFrId_gt,omitempty"`
	WpFrIdGte                      *int32                  `json:"wpFrId_gte,omitempty"`
	WpEnId                         *int32                  `json:"wpEnId,omitempty"`
	WpEnIdNot                      *int32                  `json:"wpEnId_not,omitempty"`
	WpEnIdIn                       []int32                 `json:"wpEnId_in,omitempty"`
	WpEnIdNotIn                    []int32                 `json:"wpEnId_not_in,omitempty"`
	WpEnIdLt                       *int32                  `json:"wpEnId_lt,omitempty"`
	WpEnIdLte                      *int32                  `json:"wpEnId_lte,omitempty"`
	WpEnIdGt                       *int32                  `json:"wpEnId_gt,omitempty"`
	WpEnIdGte                      *int32                  `json:"wpEnId_gte,omitempty"`
	PossibleDuplicate              *bool                   `json:"possibleDuplicate,omitempty"`
	PossibleDuplicateNot           *bool                   `json:"possibleDuplicate_not,omitempty"`
	ImportNotes                    *string                 `json:"importNotes,omitempty"`
	ImportNotesNot                 *string                 `json:"importNotes_not,omitempty"`
	ImportNotesIn                  []string                `json:"importNotes_in,omitempty"`
	ImportNotesNotIn               []string                `json:"importNotes_not_in,omitempty"`
	ImportNotesLt                  *string                 `json:"importNotes_lt,omitempty"`
	ImportNotesLte                 *string                 `json:"importNotes_lte,omitempty"`
	ImportNotesGt                  *string                 `json:"importNotes_gt,omitempty"`
	ImportNotesGte                 *string                 `json:"importNotes_gte,omitempty"`
	ImportNotesContains            *string                 `json:"importNotes_contains,omitempty"`
	ImportNotesNotContains         *string                 `json:"importNotes_not_contains,omitempty"`
	ImportNotesStartsWith          *string                 `json:"importNotes_starts_with,omitempty"`
	ImportNotesNotStartsWith       *string                 `json:"importNotes_not_starts_with,omitempty"`
	ImportNotesEndsWith            *string                 `json:"importNotes_ends_with,omitempty"`
	ImportNotesNotEndsWith         *string                 `json:"importNotes_not_ends_with,omitempty"`
	IsRecurring                    *bool                   `json:"isRecurring,omitempty"`
	IsRecurringNot                 *bool                   `json:"isRecurring_not,omitempty"`
	RecurrencePattern              *string                 `json:"recurrencePattern,omitempty"`
	RecurrencePatternNot           *string                 `json:"recurrencePattern_not,omitempty"`
	RecurrencePatternIn            []string                `json:"recurrencePattern_in,omitempty"`
	RecurrencePatternNotIn         []string                `json:"recurrencePattern_not_in,omitempty"`
	RecurrencePatternLt            *string                 `json:"recurrencePattern_lt,omitempty"`
	RecurrencePatternLte           *string                 `json:"recurrencePattern_lte,omitempty"`
	RecurrencePatternGt            *string                 `json:"recurrencePattern_gt,omitempty"`
	RecurrencePatternGte           *string                 `json:"recurrencePattern_gte,omitempty"`
	RecurrencePatternContains      *string                 `json:"recurrencePattern_contains,omitempty"`
	RecurrencePatternNotContains   *string                 `json:"recurrencePattern_not_contains,omitempty"`
	RecurrencePatternStartsWith    *string                 `json:"recurrencePattern_starts_with,omitempty"`
	RecurrencePatternNotStartsWith *string                 `json:"recurrencePattern_not_starts_with,omitempty"`
	RecurrencePatternEndsWith      *string                 `json:"recurrencePattern_ends_with,omitempty"`
	RecurrencePatternNotEndsWith   *string                 `json:"recurrencePattern_not_ends_with,omitempty"`
	OccurrencesAreUnique           *bool                   `json:"occurrencesAreUnique,omitempty"`
	OccurrencesAreUniqueNot        *bool                   `json:"occurrencesAreUnique_not,omitempty"`
	CreatedAt                      *string                 `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                 `json:"updatedAt_gte,omitempty"`
	And                            []EventScalarWhereInput `json:"AND,omitempty"`
	Or                             []EventScalarWhereInput `json:"OR,omitempty"`
	Not                            []EventScalarWhereInput `json:"NOT,omitempty"`
}

type RequestedCitySubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *RequestedCityWhereInput              `json:"node,omitempty"`
	And                        []RequestedCitySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RequestedCitySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RequestedCitySubscriptionWhereInput `json:"NOT,omitempty"`
}

type EventUpsertWithWhereUniqueNestedInput struct {
	Where  EventWhereUniqueInput `json:"where"`
	Update EventUpdateDataInput  `json:"update"`
	Create EventCreateInput      `json:"create"`
}

type VenueUpdateManyMutationInput struct {
	NameFr            *string  `json:"nameFr,omitempty"`
	NameEn            *string  `json:"nameEn,omitempty"`
	Lat               *float64 `json:"lat,omitempty"`
	Long              *float64 `json:"long,omitempty"`
	City              *City    `json:"city,omitempty"`
	Address           *string  `json:"address,omitempty"`
	Zip               *string  `json:"zip,omitempty"`
	Country           *string  `json:"country,omitempty"`
	Url               *string  `json:"url,omitempty"`
	WpFrId            *int32   `json:"wpFrId,omitempty"`
	WpEnId            *int32   `json:"wpEnId,omitempty"`
	PossibleDuplicate *bool    `json:"possibleDuplicate,omitempty"`
}

type EventUpdateOneRequiredWithoutOccurrencesInput struct {
	Create  *EventCreateWithoutOccurrencesInput     `json:"create,omitempty"`
	Update  *EventUpdateWithoutOccurrencesDataInput `json:"update,omitempty"`
	Upsert  *EventUpsertWithoutOccurrencesInput     `json:"upsert,omitempty"`
	Connect *EventWhereUniqueInput                  `json:"connect,omitempty"`
}

type EventUpdateWithoutVenueDataInput struct {
	Name                 *string                                     `json:"name,omitempty"`
	Description          *string                                     `json:"description,omitempty"`
	ShortDescription     *string                                     `json:"shortDescription,omitempty"`
	Link                 *string                                     `json:"link,omitempty"`
	ImageUrl             *string                                     `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string                                     `json:"nextOccurrenceDate,omitempty"`
	Price                *int32                                      `json:"price,omitempty"`
	Category             *EventCategory                              `json:"category,omitempty"`
	Tags                 *string                                     `json:"tags,omitempty"`
	TicketUrl            *string                                     `json:"ticketUrl,omitempty"`
	Source               *string                                     `json:"source,omitempty"`
	WpFrId               *int32                                      `json:"wpFrId,omitempty"`
	WpEnId               *int32                                      `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool                                       `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string                                     `json:"importNotes,omitempty"`
	IsRecurring          *bool                                       `json:"isRecurring,omitempty"`
	RecurrencePattern    *string                                     `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool                                       `json:"occurrencesAreUnique,omitempty"`
	Occurrences          *EventOccurrenceUpdateManyWithoutEventInput `json:"occurrences,omitempty"`
}

type EventUpdateWithoutOccurrencesDataInput struct {
	Name                 *string                           `json:"name,omitempty"`
	Description          *string                           `json:"description,omitempty"`
	ShortDescription     *string                           `json:"shortDescription,omitempty"`
	Link                 *string                           `json:"link,omitempty"`
	ImageUrl             *string                           `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string                           `json:"nextOccurrenceDate,omitempty"`
	Price                *int32                            `json:"price,omitempty"`
	Venue                *VenueUpdateOneWithoutEventsInput `json:"venue,omitempty"`
	Category             *EventCategory                    `json:"category,omitempty"`
	Tags                 *string                           `json:"tags,omitempty"`
	TicketUrl            *string                           `json:"ticketUrl,omitempty"`
	Source               *string                           `json:"source,omitempty"`
	WpFrId               *int32                            `json:"wpFrId,omitempty"`
	WpEnId               *int32                            `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool                             `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string                           `json:"importNotes,omitempty"`
	IsRecurring          *bool                             `json:"isRecurring,omitempty"`
	RecurrencePattern    *string                           `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool                             `json:"occurrencesAreUnique,omitempty"`
}

type EventUpdateManyWithoutVenueInput struct {
	Create     []EventCreateWithoutVenueInput                `json:"create,omitempty"`
	Delete     []EventWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []EventWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []EventWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []EventWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []EventUpdateWithWhereUniqueWithoutVenueInput `json:"update,omitempty"`
	Upsert     []EventUpsertWithWhereUniqueWithoutVenueInput `json:"upsert,omitempty"`
	DeleteMany []EventScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []EventUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type EventUpsertWithoutOccurrencesInput struct {
	Update EventUpdateWithoutOccurrencesDataInput `json:"update"`
	Create EventCreateWithoutOccurrencesInput     `json:"create"`
}

type EventCreateManyWithoutVenueInput struct {
	Create  []EventCreateWithoutVenueInput `json:"create,omitempty"`
	Connect []EventWhereUniqueInput        `json:"connect,omitempty"`
}

type EventOccurrenceUpdateManyMutationInput struct {
	Name        *string  `json:"name,omitempty"`
	Description *string  `json:"description,omitempty"`
	ImageUrl    *string  `json:"imageUrl,omitempty"`
	StartDate   *string  `json:"startDate,omitempty"`
	EndDate     *string  `json:"endDate,omitempty"`
	Lat         *float64 `json:"lat,omitempty"`
	Long        *float64 `json:"long,omitempty"`
	Price       *int32   `json:"price,omitempty"`
	City        *City    `json:"city,omitempty"`
	TicketUrl   *string  `json:"ticketUrl,omitempty"`
}

type UserUpdateInput struct {
	Facebookid             *string                     `json:"facebookid,omitempty"`
	Fname                  *string                     `json:"fname,omitempty"`
	Lname                  *string                     `json:"lname,omitempty"`
	Picture                *string                     `json:"picture,omitempty"`
	Email                  *string                     `json:"email,omitempty"`
	Password               *string                     `json:"password,omitempty"`
	Sex                    *Sex                        `json:"sex,omitempty"`
	Age                    *int32                      `json:"age,omitempty"`
	City                   *City                       `json:"city,omitempty"`
	Permissions            *UserUpdatepermissionsInput `json:"permissions,omitempty"`
	Relationship           *Relationship               `json:"relationship,omitempty"`
	SuggestedEvents        *EventUpdateManyInput       `json:"suggestedEvents,omitempty"`
	InterestedEvents       *EventUpdateManyInput       `json:"interestedEvents,omitempty"`
	BoringEvents           *EventUpdateManyInput       `json:"boringEvents,omitempty"`
	LastInteraction        *string                     `json:"lastInteraction,omitempty"`
	MessengerNotifications *Notification               `json:"messengerNotifications,omitempty"`
}

type RequestedCityCreateInput struct {
	ID        *string             `json:"id,omitempty"`
	City      string              `json:"city"`
	User      *UserCreateOneInput `json:"user,omitempty"`
	SendEmail *bool               `json:"sendEmail,omitempty"`
}

type EventOccurrenceUpdateDataInput struct {
	Name        *string                                        `json:"name,omitempty"`
	Description *string                                        `json:"description,omitempty"`
	ImageUrl    *string                                        `json:"imageUrl,omitempty"`
	StartDate   *string                                        `json:"startDate,omitempty"`
	EndDate     *string                                        `json:"endDate,omitempty"`
	Lat         *float64                                       `json:"lat,omitempty"`
	Long        *float64                                       `json:"long,omitempty"`
	Price       *int32                                         `json:"price,omitempty"`
	City        *City                                          `json:"city,omitempty"`
	TicketUrl   *string                                        `json:"ticketUrl,omitempty"`
	Event       *EventUpdateOneRequiredWithoutOccurrencesInput `json:"event,omitempty"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type SearchUpdateInput struct {
	City             *City                           `json:"city,omitempty"`
	StartDate        *string                         `json:"startDate,omitempty"`
	EndDate          *string                         `json:"endDate,omitempty"`
	Info             *string                         `json:"info,omitempty"`
	Suggested        *int32                          `json:"suggested,omitempty"`
	User             *UserUpdateOneInput             `json:"user,omitempty"`
	Events           *EventUpdateManyInput           `json:"events,omitempty"`
	EventOccurrences *EventOccurrenceUpdateManyInput `json:"eventOccurrences,omitempty"`
}

type UserCreateInput struct {
	ID                     *string                     `json:"id,omitempty"`
	Facebookid             *string                     `json:"facebookid,omitempty"`
	Fname                  *string                     `json:"fname,omitempty"`
	Lname                  *string                     `json:"lname,omitempty"`
	Picture                *string                     `json:"picture,omitempty"`
	Email                  *string                     `json:"email,omitempty"`
	Password               *string                     `json:"password,omitempty"`
	Sex                    *Sex                        `json:"sex,omitempty"`
	Age                    *int32                      `json:"age,omitempty"`
	City                   *City                       `json:"city,omitempty"`
	Permissions            *UserCreatepermissionsInput `json:"permissions,omitempty"`
	Relationship           *Relationship               `json:"relationship,omitempty"`
	SuggestedEvents        *EventCreateManyInput       `json:"suggestedEvents,omitempty"`
	InterestedEvents       *EventCreateManyInput       `json:"interestedEvents,omitempty"`
	BoringEvents           *EventCreateManyInput       `json:"boringEvents,omitempty"`
	LastInteraction        string                      `json:"lastInteraction"`
	MessengerNotifications *Notification               `json:"messengerNotifications,omitempty"`
}

type RequestedCityWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserCreatepermissionsInput struct {
	Set []Permission `json:"set,omitempty"`
}

type UserWhereInput struct {
	ID                          *string          `json:"id,omitempty"`
	IDNot                       *string          `json:"id_not,omitempty"`
	IDIn                        []string         `json:"id_in,omitempty"`
	IDNotIn                     []string         `json:"id_not_in,omitempty"`
	IDLt                        *string          `json:"id_lt,omitempty"`
	IDLte                       *string          `json:"id_lte,omitempty"`
	IDGt                        *string          `json:"id_gt,omitempty"`
	IDGte                       *string          `json:"id_gte,omitempty"`
	IDContains                  *string          `json:"id_contains,omitempty"`
	IDNotContains               *string          `json:"id_not_contains,omitempty"`
	IDStartsWith                *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string          `json:"id_not_ends_with,omitempty"`
	Facebookid                  *string          `json:"facebookid,omitempty"`
	FacebookidNot               *string          `json:"facebookid_not,omitempty"`
	FacebookidIn                []string         `json:"facebookid_in,omitempty"`
	FacebookidNotIn             []string         `json:"facebookid_not_in,omitempty"`
	FacebookidLt                *string          `json:"facebookid_lt,omitempty"`
	FacebookidLte               *string          `json:"facebookid_lte,omitempty"`
	FacebookidGt                *string          `json:"facebookid_gt,omitempty"`
	FacebookidGte               *string          `json:"facebookid_gte,omitempty"`
	FacebookidContains          *string          `json:"facebookid_contains,omitempty"`
	FacebookidNotContains       *string          `json:"facebookid_not_contains,omitempty"`
	FacebookidStartsWith        *string          `json:"facebookid_starts_with,omitempty"`
	FacebookidNotStartsWith     *string          `json:"facebookid_not_starts_with,omitempty"`
	FacebookidEndsWith          *string          `json:"facebookid_ends_with,omitempty"`
	FacebookidNotEndsWith       *string          `json:"facebookid_not_ends_with,omitempty"`
	Fname                       *string          `json:"fname,omitempty"`
	FnameNot                    *string          `json:"fname_not,omitempty"`
	FnameIn                     []string         `json:"fname_in,omitempty"`
	FnameNotIn                  []string         `json:"fname_not_in,omitempty"`
	FnameLt                     *string          `json:"fname_lt,omitempty"`
	FnameLte                    *string          `json:"fname_lte,omitempty"`
	FnameGt                     *string          `json:"fname_gt,omitempty"`
	FnameGte                    *string          `json:"fname_gte,omitempty"`
	FnameContains               *string          `json:"fname_contains,omitempty"`
	FnameNotContains            *string          `json:"fname_not_contains,omitempty"`
	FnameStartsWith             *string          `json:"fname_starts_with,omitempty"`
	FnameNotStartsWith          *string          `json:"fname_not_starts_with,omitempty"`
	FnameEndsWith               *string          `json:"fname_ends_with,omitempty"`
	FnameNotEndsWith            *string          `json:"fname_not_ends_with,omitempty"`
	Lname                       *string          `json:"lname,omitempty"`
	LnameNot                    *string          `json:"lname_not,omitempty"`
	LnameIn                     []string         `json:"lname_in,omitempty"`
	LnameNotIn                  []string         `json:"lname_not_in,omitempty"`
	LnameLt                     *string          `json:"lname_lt,omitempty"`
	LnameLte                    *string          `json:"lname_lte,omitempty"`
	LnameGt                     *string          `json:"lname_gt,omitempty"`
	LnameGte                    *string          `json:"lname_gte,omitempty"`
	LnameContains               *string          `json:"lname_contains,omitempty"`
	LnameNotContains            *string          `json:"lname_not_contains,omitempty"`
	LnameStartsWith             *string          `json:"lname_starts_with,omitempty"`
	LnameNotStartsWith          *string          `json:"lname_not_starts_with,omitempty"`
	LnameEndsWith               *string          `json:"lname_ends_with,omitempty"`
	LnameNotEndsWith            *string          `json:"lname_not_ends_with,omitempty"`
	Picture                     *string          `json:"picture,omitempty"`
	PictureNot                  *string          `json:"picture_not,omitempty"`
	PictureIn                   []string         `json:"picture_in,omitempty"`
	PictureNotIn                []string         `json:"picture_not_in,omitempty"`
	PictureLt                   *string          `json:"picture_lt,omitempty"`
	PictureLte                  *string          `json:"picture_lte,omitempty"`
	PictureGt                   *string          `json:"picture_gt,omitempty"`
	PictureGte                  *string          `json:"picture_gte,omitempty"`
	PictureContains             *string          `json:"picture_contains,omitempty"`
	PictureNotContains          *string          `json:"picture_not_contains,omitempty"`
	PictureStartsWith           *string          `json:"picture_starts_with,omitempty"`
	PictureNotStartsWith        *string          `json:"picture_not_starts_with,omitempty"`
	PictureEndsWith             *string          `json:"picture_ends_with,omitempty"`
	PictureNotEndsWith          *string          `json:"picture_not_ends_with,omitempty"`
	Email                       *string          `json:"email,omitempty"`
	EmailNot                    *string          `json:"email_not,omitempty"`
	EmailIn                     []string         `json:"email_in,omitempty"`
	EmailNotIn                  []string         `json:"email_not_in,omitempty"`
	EmailLt                     *string          `json:"email_lt,omitempty"`
	EmailLte                    *string          `json:"email_lte,omitempty"`
	EmailGt                     *string          `json:"email_gt,omitempty"`
	EmailGte                    *string          `json:"email_gte,omitempty"`
	EmailContains               *string          `json:"email_contains,omitempty"`
	EmailNotContains            *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith             *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith          *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith               *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith            *string          `json:"email_not_ends_with,omitempty"`
	Password                    *string          `json:"password,omitempty"`
	PasswordNot                 *string          `json:"password_not,omitempty"`
	PasswordIn                  []string         `json:"password_in,omitempty"`
	PasswordNotIn               []string         `json:"password_not_in,omitempty"`
	PasswordLt                  *string          `json:"password_lt,omitempty"`
	PasswordLte                 *string          `json:"password_lte,omitempty"`
	PasswordGt                  *string          `json:"password_gt,omitempty"`
	PasswordGte                 *string          `json:"password_gte,omitempty"`
	PasswordContains            *string          `json:"password_contains,omitempty"`
	PasswordNotContains         *string          `json:"password_not_contains,omitempty"`
	PasswordStartsWith          *string          `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith       *string          `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith            *string          `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith         *string          `json:"password_not_ends_with,omitempty"`
	Sex                         *Sex             `json:"sex,omitempty"`
	SexNot                      *Sex             `json:"sex_not,omitempty"`
	SexIn                       []Sex            `json:"sex_in,omitempty"`
	SexNotIn                    []Sex            `json:"sex_not_in,omitempty"`
	Age                         *int32           `json:"age,omitempty"`
	AgeNot                      *int32           `json:"age_not,omitempty"`
	AgeIn                       []int32          `json:"age_in,omitempty"`
	AgeNotIn                    []int32          `json:"age_not_in,omitempty"`
	AgeLt                       *int32           `json:"age_lt,omitempty"`
	AgeLte                      *int32           `json:"age_lte,omitempty"`
	AgeGt                       *int32           `json:"age_gt,omitempty"`
	AgeGte                      *int32           `json:"age_gte,omitempty"`
	City                        *City            `json:"city,omitempty"`
	CityNot                     *City            `json:"city_not,omitempty"`
	CityIn                      []City           `json:"city_in,omitempty"`
	CityNotIn                   []City           `json:"city_not_in,omitempty"`
	Relationship                *Relationship    `json:"relationship,omitempty"`
	RelationshipNot             *Relationship    `json:"relationship_not,omitempty"`
	RelationshipIn              []Relationship   `json:"relationship_in,omitempty"`
	RelationshipNotIn           []Relationship   `json:"relationship_not_in,omitempty"`
	SuggestedEventsEvery        *EventWhereInput `json:"suggestedEvents_every,omitempty"`
	SuggestedEventsSome         *EventWhereInput `json:"suggestedEvents_some,omitempty"`
	SuggestedEventsNone         *EventWhereInput `json:"suggestedEvents_none,omitempty"`
	InterestedEventsEvery       *EventWhereInput `json:"interestedEvents_every,omitempty"`
	InterestedEventsSome        *EventWhereInput `json:"interestedEvents_some,omitempty"`
	InterestedEventsNone        *EventWhereInput `json:"interestedEvents_none,omitempty"`
	BoringEventsEvery           *EventWhereInput `json:"boringEvents_every,omitempty"`
	BoringEventsSome            *EventWhereInput `json:"boringEvents_some,omitempty"`
	BoringEventsNone            *EventWhereInput `json:"boringEvents_none,omitempty"`
	CreatedAt                   *string          `json:"createdAt,omitempty"`
	CreatedAtNot                *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string          `json:"updatedAt_gte,omitempty"`
	LastInteraction             *string          `json:"lastInteraction,omitempty"`
	LastInteractionNot          *string          `json:"lastInteraction_not,omitempty"`
	LastInteractionIn           []string         `json:"lastInteraction_in,omitempty"`
	LastInteractionNotIn        []string         `json:"lastInteraction_not_in,omitempty"`
	LastInteractionLt           *string          `json:"lastInteraction_lt,omitempty"`
	LastInteractionLte          *string          `json:"lastInteraction_lte,omitempty"`
	LastInteractionGt           *string          `json:"lastInteraction_gt,omitempty"`
	LastInteractionGte          *string          `json:"lastInteraction_gte,omitempty"`
	MessengerNotifications      *Notification    `json:"messengerNotifications,omitempty"`
	MessengerNotificationsNot   *Notification    `json:"messengerNotifications_not,omitempty"`
	MessengerNotificationsIn    []Notification   `json:"messengerNotifications_in,omitempty"`
	MessengerNotificationsNotIn []Notification   `json:"messengerNotifications_not_in,omitempty"`
	And                         []UserWhereInput `json:"AND,omitempty"`
	Or                          []UserWhereInput `json:"OR,omitempty"`
	Not                         []UserWhereInput `json:"NOT,omitempty"`
}

type EventCreateManyInput struct {
	Create  []EventCreateInput      `json:"create,omitempty"`
	Connect []EventWhereUniqueInput `json:"connect,omitempty"`
}

type VenueCreateInput struct {
	ID                *string                           `json:"id,omitempty"`
	NameFr            string                            `json:"nameFr"`
	NameEn            string                            `json:"nameEn"`
	Lat               float64                           `json:"lat"`
	Long              float64                           `json:"long"`
	City              City                              `json:"city"`
	Address           *string                           `json:"address,omitempty"`
	Zip               *string                           `json:"zip,omitempty"`
	Country           *string                           `json:"country,omitempty"`
	Url               *string                           `json:"url,omitempty"`
	WpFrId            *int32                            `json:"wpFrId,omitempty"`
	WpEnId            *int32                            `json:"wpEnId,omitempty"`
	Events            *EventCreateManyWithoutVenueInput `json:"events,omitempty"`
	PossibleDuplicate *bool                             `json:"possibleDuplicate,omitempty"`
}

type RequestedCityUpdateInput struct {
	City      *string             `json:"city,omitempty"`
	User      *UserUpdateOneInput `json:"user,omitempty"`
	SendEmail *bool               `json:"sendEmail,omitempty"`
}

type EventOccurrenceUpdateManyInput struct {
	Create     []EventOccurrenceCreateInput                      `json:"create,omitempty"`
	Update     []EventOccurrenceUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []EventOccurrenceUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []EventOccurrenceWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []EventOccurrenceWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []EventOccurrenceWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []EventOccurrenceWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []EventOccurrenceScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []EventOccurrenceUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type UserUpdateOneInput struct {
	Create     *UserCreateInput       `json:"create,omitempty"`
	Update     *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert     *UserUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                  `json:"delete,omitempty"`
	Disconnect *bool                  `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type EventOccurrenceWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EventUpdateWithWhereUniqueNestedInput struct {
	Where EventWhereUniqueInput `json:"where"`
	Data  EventUpdateDataInput  `json:"data"`
}

type EventUpdateManyInput struct {
	Create     []EventCreateInput                      `json:"create,omitempty"`
	Update     []EventUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []EventUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []EventWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []EventWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []EventWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []EventWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []EventScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []EventUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type UserUpdatepermissionsInput struct {
	Set []Permission `json:"set,omitempty"`
}

type UserUpdateDataInput struct {
	Facebookid             *string                     `json:"facebookid,omitempty"`
	Fname                  *string                     `json:"fname,omitempty"`
	Lname                  *string                     `json:"lname,omitempty"`
	Picture                *string                     `json:"picture,omitempty"`
	Email                  *string                     `json:"email,omitempty"`
	Password               *string                     `json:"password,omitempty"`
	Sex                    *Sex                        `json:"sex,omitempty"`
	Age                    *int32                      `json:"age,omitempty"`
	City                   *City                       `json:"city,omitempty"`
	Permissions            *UserUpdatepermissionsInput `json:"permissions,omitempty"`
	Relationship           *Relationship               `json:"relationship,omitempty"`
	SuggestedEvents        *EventUpdateManyInput       `json:"suggestedEvents,omitempty"`
	InterestedEvents       *EventUpdateManyInput       `json:"interestedEvents,omitempty"`
	BoringEvents           *EventUpdateManyInput       `json:"boringEvents,omitempty"`
	LastInteraction        *string                     `json:"lastInteraction,omitempty"`
	MessengerNotifications *Notification               `json:"messengerNotifications,omitempty"`
}

type VenueWhereInput struct {
	ID                   *string           `json:"id,omitempty"`
	IDNot                *string           `json:"id_not,omitempty"`
	IDIn                 []string          `json:"id_in,omitempty"`
	IDNotIn              []string          `json:"id_not_in,omitempty"`
	IDLt                 *string           `json:"id_lt,omitempty"`
	IDLte                *string           `json:"id_lte,omitempty"`
	IDGt                 *string           `json:"id_gt,omitempty"`
	IDGte                *string           `json:"id_gte,omitempty"`
	IDContains           *string           `json:"id_contains,omitempty"`
	IDNotContains        *string           `json:"id_not_contains,omitempty"`
	IDStartsWith         *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string           `json:"id_not_ends_with,omitempty"`
	NameFr               *string           `json:"nameFr,omitempty"`
	NameFrNot            *string           `json:"nameFr_not,omitempty"`
	NameFrIn             []string          `json:"nameFr_in,omitempty"`
	NameFrNotIn          []string          `json:"nameFr_not_in,omitempty"`
	NameFrLt             *string           `json:"nameFr_lt,omitempty"`
	NameFrLte            *string           `json:"nameFr_lte,omitempty"`
	NameFrGt             *string           `json:"nameFr_gt,omitempty"`
	NameFrGte            *string           `json:"nameFr_gte,omitempty"`
	NameFrContains       *string           `json:"nameFr_contains,omitempty"`
	NameFrNotContains    *string           `json:"nameFr_not_contains,omitempty"`
	NameFrStartsWith     *string           `json:"nameFr_starts_with,omitempty"`
	NameFrNotStartsWith  *string           `json:"nameFr_not_starts_with,omitempty"`
	NameFrEndsWith       *string           `json:"nameFr_ends_with,omitempty"`
	NameFrNotEndsWith    *string           `json:"nameFr_not_ends_with,omitempty"`
	NameEn               *string           `json:"nameEn,omitempty"`
	NameEnNot            *string           `json:"nameEn_not,omitempty"`
	NameEnIn             []string          `json:"nameEn_in,omitempty"`
	NameEnNotIn          []string          `json:"nameEn_not_in,omitempty"`
	NameEnLt             *string           `json:"nameEn_lt,omitempty"`
	NameEnLte            *string           `json:"nameEn_lte,omitempty"`
	NameEnGt             *string           `json:"nameEn_gt,omitempty"`
	NameEnGte            *string           `json:"nameEn_gte,omitempty"`
	NameEnContains       *string           `json:"nameEn_contains,omitempty"`
	NameEnNotContains    *string           `json:"nameEn_not_contains,omitempty"`
	NameEnStartsWith     *string           `json:"nameEn_starts_with,omitempty"`
	NameEnNotStartsWith  *string           `json:"nameEn_not_starts_with,omitempty"`
	NameEnEndsWith       *string           `json:"nameEn_ends_with,omitempty"`
	NameEnNotEndsWith    *string           `json:"nameEn_not_ends_with,omitempty"`
	Lat                  *float64          `json:"lat,omitempty"`
	LatNot               *float64          `json:"lat_not,omitempty"`
	LatIn                []float64         `json:"lat_in,omitempty"`
	LatNotIn             []float64         `json:"lat_not_in,omitempty"`
	LatLt                *float64          `json:"lat_lt,omitempty"`
	LatLte               *float64          `json:"lat_lte,omitempty"`
	LatGt                *float64          `json:"lat_gt,omitempty"`
	LatGte               *float64          `json:"lat_gte,omitempty"`
	Long                 *float64          `json:"long,omitempty"`
	LongNot              *float64          `json:"long_not,omitempty"`
	LongIn               []float64         `json:"long_in,omitempty"`
	LongNotIn            []float64         `json:"long_not_in,omitempty"`
	LongLt               *float64          `json:"long_lt,omitempty"`
	LongLte              *float64          `json:"long_lte,omitempty"`
	LongGt               *float64          `json:"long_gt,omitempty"`
	LongGte              *float64          `json:"long_gte,omitempty"`
	City                 *City             `json:"city,omitempty"`
	CityNot              *City             `json:"city_not,omitempty"`
	CityIn               []City            `json:"city_in,omitempty"`
	CityNotIn            []City            `json:"city_not_in,omitempty"`
	Address              *string           `json:"address,omitempty"`
	AddressNot           *string           `json:"address_not,omitempty"`
	AddressIn            []string          `json:"address_in,omitempty"`
	AddressNotIn         []string          `json:"address_not_in,omitempty"`
	AddressLt            *string           `json:"address_lt,omitempty"`
	AddressLte           *string           `json:"address_lte,omitempty"`
	AddressGt            *string           `json:"address_gt,omitempty"`
	AddressGte           *string           `json:"address_gte,omitempty"`
	AddressContains      *string           `json:"address_contains,omitempty"`
	AddressNotContains   *string           `json:"address_not_contains,omitempty"`
	AddressStartsWith    *string           `json:"address_starts_with,omitempty"`
	AddressNotStartsWith *string           `json:"address_not_starts_with,omitempty"`
	AddressEndsWith      *string           `json:"address_ends_with,omitempty"`
	AddressNotEndsWith   *string           `json:"address_not_ends_with,omitempty"`
	Zip                  *string           `json:"zip,omitempty"`
	ZipNot               *string           `json:"zip_not,omitempty"`
	ZipIn                []string          `json:"zip_in,omitempty"`
	ZipNotIn             []string          `json:"zip_not_in,omitempty"`
	ZipLt                *string           `json:"zip_lt,omitempty"`
	ZipLte               *string           `json:"zip_lte,omitempty"`
	ZipGt                *string           `json:"zip_gt,omitempty"`
	ZipGte               *string           `json:"zip_gte,omitempty"`
	ZipContains          *string           `json:"zip_contains,omitempty"`
	ZipNotContains       *string           `json:"zip_not_contains,omitempty"`
	ZipStartsWith        *string           `json:"zip_starts_with,omitempty"`
	ZipNotStartsWith     *string           `json:"zip_not_starts_with,omitempty"`
	ZipEndsWith          *string           `json:"zip_ends_with,omitempty"`
	ZipNotEndsWith       *string           `json:"zip_not_ends_with,omitempty"`
	Country              *string           `json:"country,omitempty"`
	CountryNot           *string           `json:"country_not,omitempty"`
	CountryIn            []string          `json:"country_in,omitempty"`
	CountryNotIn         []string          `json:"country_not_in,omitempty"`
	CountryLt            *string           `json:"country_lt,omitempty"`
	CountryLte           *string           `json:"country_lte,omitempty"`
	CountryGt            *string           `json:"country_gt,omitempty"`
	CountryGte           *string           `json:"country_gte,omitempty"`
	CountryContains      *string           `json:"country_contains,omitempty"`
	CountryNotContains   *string           `json:"country_not_contains,omitempty"`
	CountryStartsWith    *string           `json:"country_starts_with,omitempty"`
	CountryNotStartsWith *string           `json:"country_not_starts_with,omitempty"`
	CountryEndsWith      *string           `json:"country_ends_with,omitempty"`
	CountryNotEndsWith   *string           `json:"country_not_ends_with,omitempty"`
	Url                  *string           `json:"url,omitempty"`
	UrlNot               *string           `json:"url_not,omitempty"`
	UrlIn                []string          `json:"url_in,omitempty"`
	UrlNotIn             []string          `json:"url_not_in,omitempty"`
	UrlLt                *string           `json:"url_lt,omitempty"`
	UrlLte               *string           `json:"url_lte,omitempty"`
	UrlGt                *string           `json:"url_gt,omitempty"`
	UrlGte               *string           `json:"url_gte,omitempty"`
	UrlContains          *string           `json:"url_contains,omitempty"`
	UrlNotContains       *string           `json:"url_not_contains,omitempty"`
	UrlStartsWith        *string           `json:"url_starts_with,omitempty"`
	UrlNotStartsWith     *string           `json:"url_not_starts_with,omitempty"`
	UrlEndsWith          *string           `json:"url_ends_with,omitempty"`
	UrlNotEndsWith       *string           `json:"url_not_ends_with,omitempty"`
	WpFrId               *int32            `json:"wpFrId,omitempty"`
	WpFrIdNot            *int32            `json:"wpFrId_not,omitempty"`
	WpFrIdIn             []int32           `json:"wpFrId_in,omitempty"`
	WpFrIdNotIn          []int32           `json:"wpFrId_not_in,omitempty"`
	WpFrIdLt             *int32            `json:"wpFrId_lt,omitempty"`
	WpFrIdLte            *int32            `json:"wpFrId_lte,omitempty"`
	WpFrIdGt             *int32            `json:"wpFrId_gt,omitempty"`
	WpFrIdGte            *int32            `json:"wpFrId_gte,omitempty"`
	WpEnId               *int32            `json:"wpEnId,omitempty"`
	WpEnIdNot            *int32            `json:"wpEnId_not,omitempty"`
	WpEnIdIn             []int32           `json:"wpEnId_in,omitempty"`
	WpEnIdNotIn          []int32           `json:"wpEnId_not_in,omitempty"`
	WpEnIdLt             *int32            `json:"wpEnId_lt,omitempty"`
	WpEnIdLte            *int32            `json:"wpEnId_lte,omitempty"`
	WpEnIdGt             *int32            `json:"wpEnId_gt,omitempty"`
	WpEnIdGte            *int32            `json:"wpEnId_gte,omitempty"`
	EventsEvery          *EventWhereInput  `json:"events_every,omitempty"`
	EventsSome           *EventWhereInput  `json:"events_some,omitempty"`
	EventsNone           *EventWhereInput  `json:"events_none,omitempty"`
	PossibleDuplicate    *bool             `json:"possibleDuplicate,omitempty"`
	PossibleDuplicateNot *bool             `json:"possibleDuplicate_not,omitempty"`
	And                  []VenueWhereInput `json:"AND,omitempty"`
	Or                   []VenueWhereInput `json:"OR,omitempty"`
	Not                  []VenueWhereInput `json:"NOT,omitempty"`
}

type SearchCreateInput struct {
	ID               *string                         `json:"id,omitempty"`
	City             City                            `json:"city"`
	StartDate        string                          `json:"startDate"`
	EndDate          string                          `json:"endDate"`
	Info             *string                         `json:"info,omitempty"`
	Suggested        *int32                          `json:"suggested,omitempty"`
	User             *UserCreateOneInput             `json:"user,omitempty"`
	Events           *EventCreateManyInput           `json:"events,omitempty"`
	EventOccurrences *EventOccurrenceCreateManyInput `json:"eventOccurrences,omitempty"`
}

type UserWhereUniqueInput struct {
	ID         *string `json:"id,omitempty"`
	Facebookid *string `json:"facebookid,omitempty"`
	Email      *string `json:"email,omitempty"`
}

type EventCreateWithoutVenueInput struct {
	ID                   *string                                     `json:"id,omitempty"`
	Name                 string                                      `json:"name"`
	Description          *string                                     `json:"description,omitempty"`
	ShortDescription     *string                                     `json:"shortDescription,omitempty"`
	Link                 string                                      `json:"link"`
	ImageUrl             *string                                     `json:"imageUrl,omitempty"`
	NextOccurrenceDate   *string                                     `json:"nextOccurrenceDate,omitempty"`
	Price                *int32                                      `json:"price,omitempty"`
	Category             *EventCategory                              `json:"category,omitempty"`
	Tags                 *string                                     `json:"tags,omitempty"`
	TicketUrl            *string                                     `json:"ticketUrl,omitempty"`
	Source               *string                                     `json:"source,omitempty"`
	WpFrId               *int32                                      `json:"wpFrId,omitempty"`
	WpEnId               *int32                                      `json:"wpEnId,omitempty"`
	PossibleDuplicate    *bool                                       `json:"possibleDuplicate,omitempty"`
	ImportNotes          *string                                     `json:"importNotes,omitempty"`
	IsRecurring          *bool                                       `json:"isRecurring,omitempty"`
	RecurrencePattern    *string                                     `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique *bool                                       `json:"occurrencesAreUnique,omitempty"`
	Occurrences          *EventOccurrenceCreateManyWithoutEventInput `json:"occurrences,omitempty"`
}

type VenuePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance VenuePreviousValuesExec) Exec(ctx context.Context) (*VenuePreviousValues, error) {
	var v VenuePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VenuePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VenuePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance VenuePreviousValuesExecArray) Exec(ctx context.Context) ([]VenuePreviousValues, error) {
	var v []VenuePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VenuePreviousValues struct {
	ID                string  `json:"id"`
	NameFr            string  `json:"nameFr"`
	NameEn            string  `json:"nameEn"`
	Lat               float64 `json:"lat"`
	Long              float64 `json:"long"`
	City              City    `json:"city"`
	Address           *string `json:"address,omitempty"`
	Zip               *string `json:"zip,omitempty"`
	Country           string  `json:"country"`
	Url               *string `json:"url,omitempty"`
	WpFrId            int32   `json:"wpFrId"`
	WpEnId            int32   `json:"wpEnId"`
	PossibleDuplicate bool    `json:"possibleDuplicate"`
}

type EventConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EventConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EventConnectionExec) Edges() *EventEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"EventWhereInput", "EventOrderByInput", "EventEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Event"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &EventEdgeExecArray{nodes}
}

func (instance *EventConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEvent"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance EventConnectionExec) Exec(ctx context.Context) (*EventConnection, error) {
	var v EventConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EventConnectionExecArray) Exec(ctx context.Context) ([]EventConnection, error) {
	var v []EventConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []EventEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type VenueExec struct {
	exec *prisma.Exec
}

type EventsParamsExec struct {
	Where   *EventWhereInput
	OrderBy *EventOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *VenueExec) Events(params *EventsParamsExec) *EventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EventWhereInput", "EventOrderByInput", "Event"},
		"events",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExecArray{ret}
}

func (instance VenueExec) Exec(ctx context.Context) (*Venue, error) {
	var v Venue
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VenueExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VenueExecArray struct {
	exec *prisma.Exec
}

func (instance VenueExecArray) Exec(ctx context.Context) ([]Venue, error) {
	var v []Venue
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Venue struct {
	ID                string  `json:"id"`
	NameFr            string  `json:"nameFr"`
	NameEn            string  `json:"nameEn"`
	Lat               float64 `json:"lat"`
	Long              float64 `json:"long"`
	City              City    `json:"city"`
	Address           *string `json:"address,omitempty"`
	Zip               *string `json:"zip,omitempty"`
	Country           string  `json:"country"`
	Url               *string `json:"url,omitempty"`
	WpFrId            int32   `json:"wpFrId"`
	WpEnId            int32   `json:"wpEnId"`
	PossibleDuplicate bool    `json:"possibleDuplicate"`
}

type EventOccurrenceExec struct {
	exec *prisma.Exec
}

func (instance *EventOccurrenceExec) Event() *EventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Event"},
		"event",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

func (instance EventOccurrenceExec) Exec(ctx context.Context) (*EventOccurrence, error) {
	var v EventOccurrence
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventOccurrenceExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventOccurrenceExecArray struct {
	exec *prisma.Exec
}

func (instance EventOccurrenceExecArray) Exec(ctx context.Context) ([]EventOccurrence, error) {
	var v []EventOccurrence
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventOccurrence struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description string  `json:"description"`
	ImageUrl    string  `json:"imageUrl"`
	StartDate   string  `json:"startDate"`
	EndDate     *string `json:"endDate,omitempty"`
	Lat         float64 `json:"lat"`
	Long        float64 `json:"long"`
	Price       *int32  `json:"price,omitempty"`
	City        City    `json:"city"`
	TicketUrl   *string `json:"ticketUrl,omitempty"`
	CreatedAt   string  `json:"createdAt"`
}

type VenueConnectionExec struct {
	exec *prisma.Exec
}

func (instance *VenueConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *VenueConnectionExec) Edges() *VenueEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"VenueWhereInput", "VenueOrderByInput", "VenueEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Venue"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &VenueEdgeExecArray{nodes}
}

func (instance *VenueConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateVenue"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance VenueConnectionExec) Exec(ctx context.Context) (*VenueConnection, error) {
	var v VenueConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VenueConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VenueConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance VenueConnectionExecArray) Exec(ctx context.Context) ([]VenueConnection, error) {
	var v []VenueConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VenueConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []VenueEdge `json:"edges"`
}

type UserExec struct {
	exec *prisma.Exec
}

type SuggestedEventsParamsExec struct {
	Where   *EventWhereInput
	OrderBy *EventOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) SuggestedEvents(params *SuggestedEventsParamsExec) *EventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EventWhereInput", "EventOrderByInput", "Event"},
		"suggestedEvents",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExecArray{ret}
}

type InterestedEventsParamsExec struct {
	Where   *EventWhereInput
	OrderBy *EventOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) InterestedEvents(params *InterestedEventsParamsExec) *EventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EventWhereInput", "EventOrderByInput", "Event"},
		"interestedEvents",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExecArray{ret}
}

type BoringEventsParamsExec struct {
	Where   *EventWhereInput
	OrderBy *EventOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) BoringEvents(params *BoringEventsParamsExec) *EventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EventWhereInput", "EventOrderByInput", "Event"},
		"boringEvents",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID                     string        `json:"id"`
	Facebookid             *string       `json:"facebookid,omitempty"`
	Fname                  *string       `json:"fname,omitempty"`
	Lname                  *string       `json:"lname,omitempty"`
	Picture                *string       `json:"picture,omitempty"`
	Email                  *string       `json:"email,omitempty"`
	Password               *string       `json:"password,omitempty"`
	Sex                    *Sex          `json:"sex,omitempty"`
	Age                    *int32        `json:"age,omitempty"`
	City                   *City         `json:"city,omitempty"`
	Permissions            []Permission  `json:"permissions,omitempty"`
	Relationship           *Relationship `json:"relationship,omitempty"`
	CreatedAt              string        `json:"createdAt"`
	UpdatedAt              string        `json:"updatedAt"`
	LastInteraction        string        `json:"lastInteraction"`
	MessengerNotifications Notification  `json:"messengerNotifications"`
}

type RequestedCityExec struct {
	exec *prisma.Exec
}

func (instance *RequestedCityExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

func (instance RequestedCityExec) Exec(ctx context.Context) (*RequestedCity, error) {
	var v RequestedCity
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestedCityExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestedCityExecArray struct {
	exec *prisma.Exec
}

func (instance RequestedCityExecArray) Exec(ctx context.Context) ([]RequestedCity, error) {
	var v []RequestedCity
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RequestedCity struct {
	ID        string `json:"id"`
	City      string `json:"city"`
	SendEmail bool   `json:"sendEmail"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type EventExec struct {
	exec *prisma.Exec
}

func (instance *EventExec) Venue() *VenueExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Venue"},
		"venue",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

type OccurrencesParamsExec struct {
	Where   *EventOccurrenceWhereInput
	OrderBy *EventOccurrenceOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *EventExec) Occurrences(params *OccurrencesParamsExec) *EventOccurrenceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EventOccurrenceWhereInput", "EventOccurrenceOrderByInput", "EventOccurrence"},
		"occurrences",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExecArray{ret}
}

func (instance EventExec) Exec(ctx context.Context) (*Event, error) {
	var v Event
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventExecArray struct {
	exec *prisma.Exec
}

func (instance EventExecArray) Exec(ctx context.Context) ([]Event, error) {
	var v []Event
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Event struct {
	ID                   string        `json:"id"`
	Name                 string        `json:"name"`
	Description          *string       `json:"description,omitempty"`
	ShortDescription     *string       `json:"shortDescription,omitempty"`
	Link                 string        `json:"link"`
	ImageUrl             string        `json:"imageUrl"`
	NextOccurrenceDate   *string       `json:"nextOccurrenceDate,omitempty"`
	Price                *int32        `json:"price,omitempty"`
	Category             EventCategory `json:"category"`
	Tags                 *string       `json:"tags,omitempty"`
	TicketUrl            *string       `json:"ticketUrl,omitempty"`
	Source               *string       `json:"source,omitempty"`
	WpFrId               int32         `json:"wpFrId"`
	WpEnId               int32         `json:"wpEnId"`
	PossibleDuplicate    bool          `json:"possibleDuplicate"`
	ImportNotes          *string       `json:"importNotes,omitempty"`
	IsRecurring          bool          `json:"isRecurring"`
	RecurrencePattern    *string       `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique bool          `json:"occurrencesAreUnique"`
	CreatedAt            *string       `json:"createdAt,omitempty"`
	UpdatedAt            *string       `json:"updatedAt,omitempty"`
}

type EventSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EventSubscriptionPayloadExec) Node() *EventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Event"},
		"node",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

func (instance *EventSubscriptionPayloadExec) PreviousValues() *EventPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EventPreviousValues"},
		"previousValues",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventPreviousValuesExec{ret}
}

func (instance EventSubscriptionPayloadExec) Exec(ctx context.Context) (*EventSubscriptionPayload, error) {
	var v EventSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EventSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EventSubscriptionPayload, error) {
	var v []EventSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Event       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SearchConnectionExec struct {
	exec *prisma.Exec
}

func (instance *SearchConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *SearchConnectionExec) Edges() *SearchEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"SearchWhereInput", "SearchOrderByInput", "SearchEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Search"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &SearchEdgeExecArray{nodes}
}

func (instance *SearchConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateSearch"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance SearchConnectionExec) Exec(ctx context.Context) (*SearchConnection, error) {
	var v SearchConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SearchConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SearchConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance SearchConnectionExecArray) Exec(ctx context.Context) ([]SearchConnection, error) {
	var v []SearchConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SearchConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []SearchEdge `json:"edges"`
}

type EventPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EventPreviousValuesExec) Exec(ctx context.Context) (*EventPreviousValues, error) {
	var v EventPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EventPreviousValuesExecArray) Exec(ctx context.Context) ([]EventPreviousValues, error) {
	var v []EventPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventPreviousValues struct {
	ID                   string        `json:"id"`
	Name                 string        `json:"name"`
	Description          *string       `json:"description,omitempty"`
	ShortDescription     *string       `json:"shortDescription,omitempty"`
	Link                 string        `json:"link"`
	ImageUrl             string        `json:"imageUrl"`
	NextOccurrenceDate   *string       `json:"nextOccurrenceDate,omitempty"`
	Price                *int32        `json:"price,omitempty"`
	Category             EventCategory `json:"category"`
	Tags                 *string       `json:"tags,omitempty"`
	TicketUrl            *string       `json:"ticketUrl,omitempty"`
	Source               *string       `json:"source,omitempty"`
	WpFrId               int32         `json:"wpFrId"`
	WpEnId               int32         `json:"wpEnId"`
	PossibleDuplicate    bool          `json:"possibleDuplicate"`
	ImportNotes          *string       `json:"importNotes,omitempty"`
	IsRecurring          bool          `json:"isRecurring"`
	RecurrencePattern    *string       `json:"recurrencePattern,omitempty"`
	OccurrencesAreUnique bool          `json:"occurrencesAreUnique"`
	CreatedAt            *string       `json:"createdAt,omitempty"`
	UpdatedAt            *string       `json:"updatedAt,omitempty"`
}

type SearchExec struct {
	exec *prisma.Exec
}

func (instance *SearchExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

func (instance *SearchExec) Events(params *EventsParamsExec) *EventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EventWhereInput", "EventOrderByInput", "Event"},
		"events",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExecArray{ret}
}

type EventOccurrencesParamsExec struct {
	Where   *EventOccurrenceWhereInput
	OrderBy *EventOccurrenceOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *SearchExec) EventOccurrences(params *EventOccurrencesParamsExec) *EventOccurrenceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EventOccurrenceWhereInput", "EventOccurrenceOrderByInput", "EventOccurrence"},
		"eventOccurrences",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExecArray{ret}
}

func (instance SearchExec) Exec(ctx context.Context) (*Search, error) {
	var v Search
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SearchExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SearchExecArray struct {
	exec *prisma.Exec
}

func (instance SearchExecArray) Exec(ctx context.Context) ([]Search, error) {
	var v []Search
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Search struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	City      City    `json:"city"`
	StartDate string  `json:"startDate"`
	EndDate   string  `json:"endDate"`
	Info      *string `json:"info,omitempty"`
	Suggested int32   `json:"suggested"`
}

type RequestedCityEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RequestedCityEdgeExec) Node() *RequestedCityExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RequestedCity"},
		"node",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExec{ret}
}

func (instance RequestedCityEdgeExec) Exec(ctx context.Context) (*RequestedCityEdge, error) {
	var v RequestedCityEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestedCityEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestedCityEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RequestedCityEdgeExecArray) Exec(ctx context.Context) ([]RequestedCityEdge, error) {
	var v []RequestedCityEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RequestedCityEdge struct {
	Node   RequestedCity `json:"node"`
	Cursor string        `json:"cursor"`
}

type EventOccurrenceSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EventOccurrenceSubscriptionPayloadExec) Node() *EventOccurrenceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EventOccurrence"},
		"node",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExec{ret}
}

func (instance *EventOccurrenceSubscriptionPayloadExec) PreviousValues() *EventOccurrencePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EventOccurrencePreviousValues"},
		"previousValues",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrencePreviousValuesExec{ret}
}

func (instance EventOccurrenceSubscriptionPayloadExec) Exec(ctx context.Context) (*EventOccurrenceSubscriptionPayload, error) {
	var v EventOccurrenceSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventOccurrenceSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventOccurrenceSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EventOccurrenceSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EventOccurrenceSubscriptionPayload, error) {
	var v []EventOccurrenceSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventOccurrenceSubscriptionPayload struct {
	Mutation      MutationType     `json:"mutation"`
	Node          *EventOccurrence `json:"node,omitempty"`
	UpdatedFields []string         `json:"updatedFields,omitempty"`
}

type VenueSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *VenueSubscriptionPayloadExec) Node() *VenueExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Venue"},
		"node",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

func (instance *VenueSubscriptionPayloadExec) PreviousValues() *VenuePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "VenuePreviousValues"},
		"previousValues",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenuePreviousValuesExec{ret}
}

func (instance VenueSubscriptionPayloadExec) Exec(ctx context.Context) (*VenueSubscriptionPayload, error) {
	var v VenueSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VenueSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VenueSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance VenueSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]VenueSubscriptionPayload, error) {
	var v []VenueSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VenueSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Venue       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EventOccurrencePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EventOccurrencePreviousValuesExec) Exec(ctx context.Context) (*EventOccurrencePreviousValues, error) {
	var v EventOccurrencePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventOccurrencePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventOccurrencePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EventOccurrencePreviousValuesExecArray) Exec(ctx context.Context) ([]EventOccurrencePreviousValues, error) {
	var v []EventOccurrencePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventOccurrencePreviousValues struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description string  `json:"description"`
	ImageUrl    string  `json:"imageUrl"`
	StartDate   string  `json:"startDate"`
	EndDate     *string `json:"endDate,omitempty"`
	Lat         float64 `json:"lat"`
	Long        float64 `json:"long"`
	Price       *int32  `json:"price,omitempty"`
	City        City    `json:"city"`
	TicketUrl   *string `json:"ticketUrl,omitempty"`
	CreatedAt   string  `json:"createdAt"`
}

type EventEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EventEdgeExec) Node() *EventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Event"},
		"node",
		[]string{"id", "name", "description", "shortDescription", "link", "imageUrl", "nextOccurrenceDate", "price", "category", "tags", "ticketUrl", "source", "wpFrId", "wpEnId", "possibleDuplicate", "importNotes", "isRecurring", "recurrencePattern", "occurrencesAreUnique", "createdAt", "updatedAt"})

	return &EventExec{ret}
}

func (instance EventEdgeExec) Exec(ctx context.Context) (*EventEdge, error) {
	var v EventEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EventEdgeExecArray) Exec(ctx context.Context) ([]EventEdge, error) {
	var v []EventEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventEdge struct {
	Node   Event  `json:"node"`
	Cursor string `json:"cursor"`
}

type EventOccurrenceEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EventOccurrenceEdgeExec) Node() *EventOccurrenceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EventOccurrence"},
		"node",
		[]string{"id", "name", "description", "imageUrl", "startDate", "endDate", "lat", "long", "price", "city", "ticketUrl", "createdAt"})

	return &EventOccurrenceExec{ret}
}

func (instance EventOccurrenceEdgeExec) Exec(ctx context.Context) (*EventOccurrenceEdge, error) {
	var v EventOccurrenceEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventOccurrenceEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventOccurrenceEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EventOccurrenceEdgeExecArray) Exec(ctx context.Context) ([]EventOccurrenceEdge, error) {
	var v []EventOccurrenceEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventOccurrenceEdge struct {
	Node   EventOccurrence `json:"node"`
	Cursor string          `json:"cursor"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID                     string        `json:"id"`
	Facebookid             *string       `json:"facebookid,omitempty"`
	Fname                  *string       `json:"fname,omitempty"`
	Lname                  *string       `json:"lname,omitempty"`
	Picture                *string       `json:"picture,omitempty"`
	Email                  *string       `json:"email,omitempty"`
	Password               *string       `json:"password,omitempty"`
	Sex                    *Sex          `json:"sex,omitempty"`
	Age                    *int32        `json:"age,omitempty"`
	City                   *City         `json:"city,omitempty"`
	Permissions            []Permission  `json:"permissions,omitempty"`
	Relationship           *Relationship `json:"relationship,omitempty"`
	CreatedAt              string        `json:"createdAt"`
	UpdatedAt              string        `json:"updatedAt"`
	LastInteraction        string        `json:"lastInteraction"`
	MessengerNotifications Notification  `json:"messengerNotifications"`
}

type RequestedCitySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RequestedCitySubscriptionPayloadExec) Node() *RequestedCityExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RequestedCity"},
		"node",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityExec{ret}
}

func (instance *RequestedCitySubscriptionPayloadExec) PreviousValues() *RequestedCityPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RequestedCityPreviousValues"},
		"previousValues",
		[]string{"id", "city", "sendEmail"})

	return &RequestedCityPreviousValuesExec{ret}
}

func (instance RequestedCitySubscriptionPayloadExec) Exec(ctx context.Context) (*RequestedCitySubscriptionPayload, error) {
	var v RequestedCitySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestedCitySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestedCitySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RequestedCitySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RequestedCitySubscriptionPayload, error) {
	var v []RequestedCitySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RequestedCitySubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *RequestedCity `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SearchPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SearchPreviousValuesExec) Exec(ctx context.Context) (*SearchPreviousValues, error) {
	var v SearchPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SearchPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SearchPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SearchPreviousValuesExecArray) Exec(ctx context.Context) ([]SearchPreviousValues, error) {
	var v []SearchPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SearchPreviousValues struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	City      City    `json:"city"`
	StartDate string  `json:"startDate"`
	EndDate   string  `json:"endDate"`
	Info      *string `json:"info,omitempty"`
	Suggested int32   `json:"suggested"`
}

type SearchSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *SearchSubscriptionPayloadExec) Node() *SearchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Search"},
		"node",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExec{ret}
}

func (instance *SearchSubscriptionPayloadExec) PreviousValues() *SearchPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SearchPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchPreviousValuesExec{ret}
}

func (instance SearchSubscriptionPayloadExec) Exec(ctx context.Context) (*SearchSubscriptionPayload, error) {
	var v SearchSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SearchSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SearchSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance SearchSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]SearchSubscriptionPayload, error) {
	var v []SearchSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SearchSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Search      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EventOccurrenceConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EventOccurrenceConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EventOccurrenceConnectionExec) Edges() *EventOccurrenceEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"EventOccurrenceWhereInput", "EventOccurrenceOrderByInput", "EventOccurrenceEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "EventOccurrence"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &EventOccurrenceEdgeExecArray{nodes}
}

func (instance *EventOccurrenceConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEventOccurrence"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance EventOccurrenceConnectionExec) Exec(ctx context.Context) (*EventOccurrenceConnection, error) {
	var v EventOccurrenceConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EventOccurrenceConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EventOccurrenceConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EventOccurrenceConnectionExecArray) Exec(ctx context.Context) ([]EventOccurrenceConnection, error) {
	var v []EventOccurrenceConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EventOccurrenceConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []EventOccurrenceEdge `json:"edges"`
}

type RequestedCityPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RequestedCityPreviousValuesExec) Exec(ctx context.Context) (*RequestedCityPreviousValues, error) {
	var v RequestedCityPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestedCityPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestedCityPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RequestedCityPreviousValuesExecArray) Exec(ctx context.Context) ([]RequestedCityPreviousValues, error) {
	var v []RequestedCityPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RequestedCityPreviousValues struct {
	ID        string `json:"id"`
	City      string `json:"city"`
	SendEmail bool   `json:"sendEmail"`
}

type SearchEdgeExec struct {
	exec *prisma.Exec
}

func (instance *SearchEdgeExec) Node() *SearchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Search"},
		"node",
		[]string{"id", "createdAt", "city", "startDate", "endDate", "info", "suggested"})

	return &SearchExec{ret}
}

func (instance SearchEdgeExec) Exec(ctx context.Context) (*SearchEdge, error) {
	var v SearchEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SearchEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SearchEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance SearchEdgeExecArray) Exec(ctx context.Context) ([]SearchEdge, error) {
	var v []SearchEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SearchEdge struct {
	Node   Search `json:"node"`
	Cursor string `json:"cursor"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "facebookid", "fname", "lname", "picture", "email", "password", "sex", "age", "city", "permissions", "relationship", "createdAt", "updatedAt", "lastInteraction", "messengerNotifications"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type VenueEdgeExec struct {
	exec *prisma.Exec
}

func (instance *VenueEdgeExec) Node() *VenueExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Venue"},
		"node",
		[]string{"id", "nameFr", "nameEn", "lat", "long", "city", "address", "zip", "country", "url", "wpFrId", "wpEnId", "possibleDuplicate"})

	return &VenueExec{ret}
}

func (instance VenueEdgeExec) Exec(ctx context.Context) (*VenueEdge, error) {
	var v VenueEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VenueEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VenueEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance VenueEdgeExecArray) Exec(ctx context.Context) ([]VenueEdge, error) {
	var v []VenueEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type VenueEdge struct {
	Node   Venue  `json:"node"`
	Cursor string `json:"cursor"`
}

type RequestedCityConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RequestedCityConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RequestedCityConnectionExec) Edges() *RequestedCityEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"RequestedCityWhereInput", "RequestedCityOrderByInput", "RequestedCityEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "RequestedCity"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &RequestedCityEdgeExecArray{nodes}
}

func (instance *RequestedCityConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRequestedCity"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance RequestedCityConnectionExec) Exec(ctx context.Context) (*RequestedCityConnection, error) {
	var v RequestedCityConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestedCityConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestedCityConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RequestedCityConnectionExecArray) Exec(ctx context.Context) ([]RequestedCityConnection, error) {
	var v []RequestedCityConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RequestedCityConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []RequestedCityEdge `json:"edges"`
}
