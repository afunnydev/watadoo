// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  event: (where?: EventWhereInput) => Promise<boolean>;
  eventOccurrence: (where?: EventOccurrenceWhereInput) => Promise<boolean>;
  requestedCity: (where?: RequestedCityWhereInput) => Promise<boolean>;
  search: (where?: SearchWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  venue: (where?: VenueWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  eventOccurrence: (
    where: EventOccurrenceWhereUniqueInput
  ) => EventOccurrenceNullablePromise;
  eventOccurrences: (args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EventOccurrence>;
  eventOccurrencesConnection: (args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventOccurrenceConnectionPromise;
  requestedCity: (
    where: RequestedCityWhereUniqueInput
  ) => RequestedCityNullablePromise;
  requestedCities: (args?: {
    where?: RequestedCityWhereInput;
    orderBy?: RequestedCityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RequestedCity>;
  requestedCitiesConnection: (args?: {
    where?: RequestedCityWhereInput;
    orderBy?: RequestedCityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RequestedCityConnectionPromise;
  search: (where: SearchWhereUniqueInput) => SearchNullablePromise;
  searches: (args?: {
    where?: SearchWhereInput;
    orderBy?: SearchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Search>;
  searchesConnection: (args?: {
    where?: SearchWhereInput;
    orderBy?: SearchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SearchConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  venue: (where: VenueWhereUniqueInput) => VenueNullablePromise;
  venues: (args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Venue>;
  venuesConnection: (args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VenueConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createEventOccurrence: (
    data: EventOccurrenceCreateInput
  ) => EventOccurrencePromise;
  updateEventOccurrence: (args: {
    data: EventOccurrenceUpdateInput;
    where: EventOccurrenceWhereUniqueInput;
  }) => EventOccurrencePromise;
  updateManyEventOccurrences: (args: {
    data: EventOccurrenceUpdateManyMutationInput;
    where?: EventOccurrenceWhereInput;
  }) => BatchPayloadPromise;
  upsertEventOccurrence: (args: {
    where: EventOccurrenceWhereUniqueInput;
    create: EventOccurrenceCreateInput;
    update: EventOccurrenceUpdateInput;
  }) => EventOccurrencePromise;
  deleteEventOccurrence: (
    where: EventOccurrenceWhereUniqueInput
  ) => EventOccurrencePromise;
  deleteManyEventOccurrences: (
    where?: EventOccurrenceWhereInput
  ) => BatchPayloadPromise;
  createRequestedCity: (data: RequestedCityCreateInput) => RequestedCityPromise;
  updateRequestedCity: (args: {
    data: RequestedCityUpdateInput;
    where: RequestedCityWhereUniqueInput;
  }) => RequestedCityPromise;
  updateManyRequestedCities: (args: {
    data: RequestedCityUpdateManyMutationInput;
    where?: RequestedCityWhereInput;
  }) => BatchPayloadPromise;
  upsertRequestedCity: (args: {
    where: RequestedCityWhereUniqueInput;
    create: RequestedCityCreateInput;
    update: RequestedCityUpdateInput;
  }) => RequestedCityPromise;
  deleteRequestedCity: (
    where: RequestedCityWhereUniqueInput
  ) => RequestedCityPromise;
  deleteManyRequestedCities: (
    where?: RequestedCityWhereInput
  ) => BatchPayloadPromise;
  createSearch: (data: SearchCreateInput) => SearchPromise;
  updateSearch: (args: {
    data: SearchUpdateInput;
    where: SearchWhereUniqueInput;
  }) => SearchPromise;
  updateManySearches: (args: {
    data: SearchUpdateManyMutationInput;
    where?: SearchWhereInput;
  }) => BatchPayloadPromise;
  upsertSearch: (args: {
    where: SearchWhereUniqueInput;
    create: SearchCreateInput;
    update: SearchUpdateInput;
  }) => SearchPromise;
  deleteSearch: (where: SearchWhereUniqueInput) => SearchPromise;
  deleteManySearches: (where?: SearchWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVenue: (data: VenueCreateInput) => VenuePromise;
  updateVenue: (args: {
    data: VenueUpdateInput;
    where: VenueWhereUniqueInput;
  }) => VenuePromise;
  updateManyVenues: (args: {
    data: VenueUpdateManyMutationInput;
    where?: VenueWhereInput;
  }) => BatchPayloadPromise;
  upsertVenue: (args: {
    where: VenueWhereUniqueInput;
    create: VenueCreateInput;
    update: VenueUpdateInput;
  }) => VenuePromise;
  deleteVenue: (where: VenueWhereUniqueInput) => VenuePromise;
  deleteManyVenues: (where?: VenueWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  eventOccurrence: (
    where?: EventOccurrenceSubscriptionWhereInput
  ) => EventOccurrenceSubscriptionPayloadSubscription;
  requestedCity: (
    where?: RequestedCitySubscriptionWhereInput
  ) => RequestedCitySubscriptionPayloadSubscription;
  search: (
    where?: SearchSubscriptionWhereInput
  ) => SearchSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  venue: (
    where?: VenueSubscriptionWhereInput
  ) => VenueSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type City = "GATINEAU" | "OTTAWA" | "MONTREAL" | "QUEBEC" | "TORONTO";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "link_ASC"
  | "link_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC"
  | "nextOccurrenceDate_ASC"
  | "nextOccurrenceDate_DESC"
  | "price_ASC"
  | "price_DESC"
  | "category_ASC"
  | "category_DESC"
  | "tags_ASC"
  | "tags_DESC"
  | "ticketUrl_ASC"
  | "ticketUrl_DESC"
  | "source_ASC"
  | "source_DESC"
  | "wpFrId_ASC"
  | "wpFrId_DESC"
  | "wpEnId_ASC"
  | "wpEnId_DESC"
  | "possibleDuplicate_ASC"
  | "possibleDuplicate_DESC"
  | "importNotes_ASC"
  | "importNotes_DESC"
  | "isRecurring_ASC"
  | "isRecurring_DESC"
  | "recurrencePattern_ASC"
  | "recurrencePattern_DESC"
  | "occurrencesAreUnique_ASC"
  | "occurrencesAreUnique_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Relationship = "COUPLE" | "SINGLE" | "MARRIED" | "OTHER" | "NONE";

export type VenueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nameFr_ASC"
  | "nameFr_DESC"
  | "nameEn_ASC"
  | "nameEn_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "long_ASC"
  | "long_DESC"
  | "city_ASC"
  | "city_DESC"
  | "address_ASC"
  | "address_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "country_ASC"
  | "country_DESC"
  | "url_ASC"
  | "url_DESC"
  | "wpFrId_ASC"
  | "wpFrId_DESC"
  | "wpEnId_ASC"
  | "wpEnId_DESC"
  | "possibleDuplicate_ASC"
  | "possibleDuplicate_DESC";

export type EventOccurrenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "long_ASC"
  | "long_DESC"
  | "price_ASC"
  | "price_DESC"
  | "city_ASC"
  | "city_DESC"
  | "ticketUrl_ASC"
  | "ticketUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type EventCategory =
  | "ACTIVITES"
  | "COMEDY"
  | "FAMILY"
  | "FESTIVALS"
  | "FOOD"
  | "MUSEUMS"
  | "MUSIC"
  | "SPORTS"
  | "THEATER"
  | "VARIETY"
  | "OTHER"
  | "UNKNOWN";

export type Sex = "MALE" | "FEMALE" | "OTHER";

export type Permission = "USER" | "MANAGEEVENT" | "ADMIN";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "facebookid_ASC"
  | "facebookid_DESC"
  | "fname_ASC"
  | "fname_DESC"
  | "lname_ASC"
  | "lname_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "sex_ASC"
  | "sex_DESC"
  | "age_ASC"
  | "age_DESC"
  | "city_ASC"
  | "city_DESC"
  | "relationship_ASC"
  | "relationship_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "lastInteraction_ASC"
  | "lastInteraction_DESC"
  | "messengerNotifications_ASC"
  | "messengerNotifications_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type Notification =
  | "ANYTIME"
  | "WEEKLY"
  | "BIWEEKLY"
  | "MONTHLY"
  | "NEVER";

export type RequestedCityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "city_ASC"
  | "city_DESC"
  | "sendEmail_ASC"
  | "sendEmail_DESC";

export type SearchOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "city_ASC"
  | "city_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "info_ASC"
  | "info_DESC"
  | "suggested_ASC"
  | "suggested_DESC";

export interface EventOccurrenceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  long?: Maybe<Float>;
  long_not?: Maybe<Float>;
  long_in?: Maybe<Float[] | Float>;
  long_not_in?: Maybe<Float[] | Float>;
  long_lt?: Maybe<Float>;
  long_lte?: Maybe<Float>;
  long_gt?: Maybe<Float>;
  long_gte?: Maybe<Float>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  city?: Maybe<City>;
  city_not?: Maybe<City>;
  city_in?: Maybe<City[] | City>;
  city_not_in?: Maybe<City[] | City>;
  ticketUrl?: Maybe<String>;
  ticketUrl_not?: Maybe<String>;
  ticketUrl_in?: Maybe<String[] | String>;
  ticketUrl_not_in?: Maybe<String[] | String>;
  ticketUrl_lt?: Maybe<String>;
  ticketUrl_lte?: Maybe<String>;
  ticketUrl_gt?: Maybe<String>;
  ticketUrl_gte?: Maybe<String>;
  ticketUrl_contains?: Maybe<String>;
  ticketUrl_not_contains?: Maybe<String>;
  ticketUrl_starts_with?: Maybe<String>;
  ticketUrl_not_starts_with?: Maybe<String>;
  ticketUrl_ends_with?: Maybe<String>;
  ticketUrl_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    EventOccurrenceScalarWhereInput[] | EventOccurrenceScalarWhereInput
  >;
  OR?: Maybe<
    EventOccurrenceScalarWhereInput[] | EventOccurrenceScalarWhereInput
  >;
  NOT?: Maybe<
    EventOccurrenceScalarWhereInput[] | EventOccurrenceScalarWhereInput
  >;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EventCreateWithoutOccurrencesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link: String;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  venue?: Maybe<VenueCreateOneWithoutEventsInput>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
}

export interface EventOccurrenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  long?: Maybe<Float>;
  long_not?: Maybe<Float>;
  long_in?: Maybe<Float[] | Float>;
  long_not_in?: Maybe<Float[] | Float>;
  long_lt?: Maybe<Float>;
  long_lte?: Maybe<Float>;
  long_gt?: Maybe<Float>;
  long_gte?: Maybe<Float>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  city?: Maybe<City>;
  city_not?: Maybe<City>;
  city_in?: Maybe<City[] | City>;
  city_not_in?: Maybe<City[] | City>;
  ticketUrl?: Maybe<String>;
  ticketUrl_not?: Maybe<String>;
  ticketUrl_in?: Maybe<String[] | String>;
  ticketUrl_not_in?: Maybe<String[] | String>;
  ticketUrl_lt?: Maybe<String>;
  ticketUrl_lte?: Maybe<String>;
  ticketUrl_gt?: Maybe<String>;
  ticketUrl_gte?: Maybe<String>;
  ticketUrl_contains?: Maybe<String>;
  ticketUrl_not_contains?: Maybe<String>;
  ticketUrl_starts_with?: Maybe<String>;
  ticketUrl_not_starts_with?: Maybe<String>;
  ticketUrl_ends_with?: Maybe<String>;
  ticketUrl_not_ends_with?: Maybe<String>;
  event?: Maybe<EventWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EventOccurrenceWhereInput[] | EventOccurrenceWhereInput>;
  OR?: Maybe<EventOccurrenceWhereInput[] | EventOccurrenceWhereInput>;
  NOT?: Maybe<EventOccurrenceWhereInput[] | EventOccurrenceWhereInput>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link: String;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  venue?: Maybe<VenueCreateOneWithoutEventsInput>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
  occurrences?: Maybe<EventOccurrenceCreateManyWithoutEventInput>;
}

export interface EventUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link?: Maybe<String>;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  venue?: Maybe<VenueUpdateOneWithoutEventsInput>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
  occurrences?: Maybe<EventOccurrenceUpdateManyWithoutEventInput>;
}

export interface VenueCreateOneWithoutEventsInput {
  create?: Maybe<VenueCreateWithoutEventsInput>;
  connect?: Maybe<VenueWhereUniqueInput>;
}

export interface EventOccurrenceUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  price?: Maybe<Int>;
  city?: Maybe<City>;
  ticketUrl?: Maybe<String>;
  event?: Maybe<EventUpdateOneRequiredWithoutOccurrencesInput>;
}

export interface VenueCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  nameFr: String;
  nameEn: String;
  lat: Float;
  long: Float;
  city: City;
  address?: Maybe<String>;
  zip?: Maybe<String>;
  country?: Maybe<String>;
  url?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface EventOccurrenceCreateManyWithoutEventInput {
  create?: Maybe<
    | EventOccurrenceCreateWithoutEventInput[]
    | EventOccurrenceCreateWithoutEventInput
  >;
  connect?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
}

export interface SearchSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SearchWhereInput>;
  AND?: Maybe<SearchSubscriptionWhereInput[] | SearchSubscriptionWhereInput>;
  OR?: Maybe<SearchSubscriptionWhereInput[] | SearchSubscriptionWhereInput>;
  NOT?: Maybe<SearchSubscriptionWhereInput[] | SearchSubscriptionWhereInput>;
}

export interface EventOccurrenceCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
  startDate: DateTimeInput;
  endDate?: Maybe<DateTimeInput>;
  lat: Float;
  long: Float;
  price?: Maybe<Int>;
  city: City;
  ticketUrl?: Maybe<String>;
}

export interface EventOccurrenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventOccurrenceWhereInput>;
  AND?: Maybe<
    | EventOccurrenceSubscriptionWhereInput[]
    | EventOccurrenceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EventOccurrenceSubscriptionWhereInput[]
    | EventOccurrenceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EventOccurrenceSubscriptionWhereInput[]
    | EventOccurrenceSubscriptionWhereInput
  >;
}

export interface EventUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link?: Maybe<String>;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  venue?: Maybe<VenueUpdateOneWithoutEventsInput>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
  occurrences?: Maybe<EventOccurrenceUpdateManyWithoutEventInput>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface VenueUpdateOneWithoutEventsInput {
  create?: Maybe<VenueCreateWithoutEventsInput>;
  update?: Maybe<VenueUpdateWithoutEventsDataInput>;
  upsert?: Maybe<VenueUpsertWithoutEventsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VenueWhereUniqueInput>;
}

export interface EventUpsertWithWhereUniqueWithoutVenueInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutVenueDataInput;
  create: EventCreateWithoutVenueInput;
}

export interface VenueUpdateWithoutEventsDataInput {
  nameFr?: Maybe<String>;
  nameEn?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  city?: Maybe<City>;
  address?: Maybe<String>;
  zip?: Maybe<String>;
  country?: Maybe<String>;
  url?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  nextOccurrenceDate_not?: Maybe<DateTimeInput>;
  nextOccurrenceDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  nextOccurrenceDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  nextOccurrenceDate_lt?: Maybe<DateTimeInput>;
  nextOccurrenceDate_lte?: Maybe<DateTimeInput>;
  nextOccurrenceDate_gt?: Maybe<DateTimeInput>;
  nextOccurrenceDate_gte?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  venue?: Maybe<VenueWhereInput>;
  category?: Maybe<EventCategory>;
  category_not?: Maybe<EventCategory>;
  category_in?: Maybe<EventCategory[] | EventCategory>;
  category_not_in?: Maybe<EventCategory[] | EventCategory>;
  tags?: Maybe<String>;
  tags_not?: Maybe<String>;
  tags_in?: Maybe<String[] | String>;
  tags_not_in?: Maybe<String[] | String>;
  tags_lt?: Maybe<String>;
  tags_lte?: Maybe<String>;
  tags_gt?: Maybe<String>;
  tags_gte?: Maybe<String>;
  tags_contains?: Maybe<String>;
  tags_not_contains?: Maybe<String>;
  tags_starts_with?: Maybe<String>;
  tags_not_starts_with?: Maybe<String>;
  tags_ends_with?: Maybe<String>;
  tags_not_ends_with?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  ticketUrl_not?: Maybe<String>;
  ticketUrl_in?: Maybe<String[] | String>;
  ticketUrl_not_in?: Maybe<String[] | String>;
  ticketUrl_lt?: Maybe<String>;
  ticketUrl_lte?: Maybe<String>;
  ticketUrl_gt?: Maybe<String>;
  ticketUrl_gte?: Maybe<String>;
  ticketUrl_contains?: Maybe<String>;
  ticketUrl_not_contains?: Maybe<String>;
  ticketUrl_starts_with?: Maybe<String>;
  ticketUrl_not_starts_with?: Maybe<String>;
  ticketUrl_ends_with?: Maybe<String>;
  ticketUrl_not_ends_with?: Maybe<String>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpFrId_not?: Maybe<Int>;
  wpFrId_in?: Maybe<Int[] | Int>;
  wpFrId_not_in?: Maybe<Int[] | Int>;
  wpFrId_lt?: Maybe<Int>;
  wpFrId_lte?: Maybe<Int>;
  wpFrId_gt?: Maybe<Int>;
  wpFrId_gte?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  wpEnId_not?: Maybe<Int>;
  wpEnId_in?: Maybe<Int[] | Int>;
  wpEnId_not_in?: Maybe<Int[] | Int>;
  wpEnId_lt?: Maybe<Int>;
  wpEnId_lte?: Maybe<Int>;
  wpEnId_gt?: Maybe<Int>;
  wpEnId_gte?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  possibleDuplicate_not?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  importNotes_not?: Maybe<String>;
  importNotes_in?: Maybe<String[] | String>;
  importNotes_not_in?: Maybe<String[] | String>;
  importNotes_lt?: Maybe<String>;
  importNotes_lte?: Maybe<String>;
  importNotes_gt?: Maybe<String>;
  importNotes_gte?: Maybe<String>;
  importNotes_contains?: Maybe<String>;
  importNotes_not_contains?: Maybe<String>;
  importNotes_starts_with?: Maybe<String>;
  importNotes_not_starts_with?: Maybe<String>;
  importNotes_ends_with?: Maybe<String>;
  importNotes_not_ends_with?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  isRecurring_not?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  recurrencePattern_not?: Maybe<String>;
  recurrencePattern_in?: Maybe<String[] | String>;
  recurrencePattern_not_in?: Maybe<String[] | String>;
  recurrencePattern_lt?: Maybe<String>;
  recurrencePattern_lte?: Maybe<String>;
  recurrencePattern_gt?: Maybe<String>;
  recurrencePattern_gte?: Maybe<String>;
  recurrencePattern_contains?: Maybe<String>;
  recurrencePattern_not_contains?: Maybe<String>;
  recurrencePattern_starts_with?: Maybe<String>;
  recurrencePattern_not_starts_with?: Maybe<String>;
  recurrencePattern_ends_with?: Maybe<String>;
  recurrencePattern_not_ends_with?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
  occurrencesAreUnique_not?: Maybe<Boolean>;
  occurrences_every?: Maybe<EventOccurrenceWhereInput>;
  occurrences_some?: Maybe<EventOccurrenceWhereInput>;
  occurrences_none?: Maybe<EventOccurrenceWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface VenueUpsertWithoutEventsInput {
  update: VenueUpdateWithoutEventsDataInput;
  create: VenueCreateWithoutEventsInput;
}

export interface RequestedCityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  sendEmail?: Maybe<Boolean>;
  sendEmail_not?: Maybe<Boolean>;
  AND?: Maybe<RequestedCityWhereInput[] | RequestedCityWhereInput>;
  OR?: Maybe<RequestedCityWhereInput[] | RequestedCityWhereInput>;
  NOT?: Maybe<RequestedCityWhereInput[] | RequestedCityWhereInput>;
}

export interface EventOccurrenceUpdateManyWithoutEventInput {
  create?: Maybe<
    | EventOccurrenceCreateWithoutEventInput[]
    | EventOccurrenceCreateWithoutEventInput
  >;
  delete?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  connect?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  set?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  disconnect?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  update?: Maybe<
    | EventOccurrenceUpdateWithWhereUniqueWithoutEventInput[]
    | EventOccurrenceUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | EventOccurrenceUpsertWithWhereUniqueWithoutEventInput[]
    | EventOccurrenceUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<
    EventOccurrenceScalarWhereInput[] | EventOccurrenceScalarWhereInput
  >;
  updateMany?: Maybe<
    | EventOccurrenceUpdateManyWithWhereNestedInput[]
    | EventOccurrenceUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutVenueInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutVenueDataInput;
}

export interface EventOccurrenceUpdateWithWhereUniqueWithoutEventInput {
  where: EventOccurrenceWhereUniqueInput;
  data: EventOccurrenceUpdateWithoutEventDataInput;
}

export interface VenueUpdateInput {
  nameFr?: Maybe<String>;
  nameEn?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  city?: Maybe<City>;
  address?: Maybe<String>;
  zip?: Maybe<String>;
  country?: Maybe<String>;
  url?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  events?: Maybe<EventUpdateManyWithoutVenueInput>;
  possibleDuplicate?: Maybe<Boolean>;
}

export interface EventOccurrenceUpdateWithoutEventDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  price?: Maybe<Int>;
  city?: Maybe<City>;
  ticketUrl?: Maybe<String>;
}

export type SearchWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EventOccurrenceUpsertWithWhereUniqueWithoutEventInput {
  where: EventOccurrenceWhereUniqueInput;
  update: EventOccurrenceUpdateWithoutEventDataInput;
  create: EventOccurrenceCreateWithoutEventInput;
}

export interface SearchWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  city?: Maybe<City>;
  city_not?: Maybe<City>;
  city_in?: Maybe<City[] | City>;
  city_not_in?: Maybe<City[] | City>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  info?: Maybe<String>;
  info_not?: Maybe<String>;
  info_in?: Maybe<String[] | String>;
  info_not_in?: Maybe<String[] | String>;
  info_lt?: Maybe<String>;
  info_lte?: Maybe<String>;
  info_gt?: Maybe<String>;
  info_gte?: Maybe<String>;
  info_contains?: Maybe<String>;
  info_not_contains?: Maybe<String>;
  info_starts_with?: Maybe<String>;
  info_not_starts_with?: Maybe<String>;
  info_ends_with?: Maybe<String>;
  info_not_ends_with?: Maybe<String>;
  suggested?: Maybe<Int>;
  suggested_not?: Maybe<Int>;
  suggested_in?: Maybe<Int[] | Int>;
  suggested_not_in?: Maybe<Int[] | Int>;
  suggested_lt?: Maybe<Int>;
  suggested_lte?: Maybe<Int>;
  suggested_gt?: Maybe<Int>;
  suggested_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  events_every?: Maybe<EventWhereInput>;
  events_some?: Maybe<EventWhereInput>;
  events_none?: Maybe<EventWhereInput>;
  eventOccurrences_every?: Maybe<EventOccurrenceWhereInput>;
  eventOccurrences_some?: Maybe<EventOccurrenceWhereInput>;
  eventOccurrences_none?: Maybe<EventOccurrenceWhereInput>;
  AND?: Maybe<SearchWhereInput[] | SearchWhereInput>;
  OR?: Maybe<SearchWhereInput[] | SearchWhereInput>;
  NOT?: Maybe<SearchWhereInput[] | SearchWhereInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserUpdateManyMutationInput {
  facebookid?: Maybe<String>;
  fname?: Maybe<String>;
  lname?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  sex?: Maybe<Sex>;
  age?: Maybe<Int>;
  city?: Maybe<City>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  relationship?: Maybe<Relationship>;
  lastInteraction?: Maybe<DateTimeInput>;
  messengerNotifications?: Maybe<Notification>;
}

export interface EventOccurrenceUpdateManyWithWhereNestedInput {
  where: EventOccurrenceScalarWhereInput;
  data: EventOccurrenceUpdateManyDataInput;
}

export interface SearchUpdateManyMutationInput {
  city?: Maybe<City>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  info?: Maybe<String>;
  suggested?: Maybe<Int>;
}

export interface EventOccurrenceUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  price?: Maybe<Int>;
  city?: Maybe<City>;
  ticketUrl?: Maybe<String>;
}

export interface EventOccurrenceUpsertWithWhereUniqueNestedInput {
  where: EventOccurrenceWhereUniqueInput;
  update: EventOccurrenceUpdateDataInput;
  create: EventOccurrenceCreateInput;
}

export interface EventUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link?: Maybe<String>;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
}

export interface EventOccurrenceUpdateWithWhereUniqueNestedInput {
  where: EventOccurrenceWhereUniqueInput;
  data: EventOccurrenceUpdateDataInput;
}

export interface EventUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link?: Maybe<String>;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
}

export type VenueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  nameFr?: Maybe<String>;
  nameEn?: Maybe<String>;
}>;

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventOccurrenceCreateManyInput {
  create?: Maybe<EventOccurrenceCreateInput[] | EventOccurrenceCreateInput>;
  connect?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
}

export interface EventOccurrenceCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
  startDate: DateTimeInput;
  endDate?: Maybe<DateTimeInput>;
  lat: Float;
  long: Float;
  price?: Maybe<Int>;
  city: City;
  ticketUrl?: Maybe<String>;
  event: EventCreateOneWithoutOccurrencesInput;
}

export interface RequestedCityUpdateManyMutationInput {
  city?: Maybe<String>;
  sendEmail?: Maybe<Boolean>;
}

export interface EventCreateOneWithoutOccurrencesInput {
  create?: Maybe<EventCreateWithoutOccurrencesInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface VenueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VenueWhereInput>;
  AND?: Maybe<VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput>;
  OR?: Maybe<VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput>;
  NOT?: Maybe<VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput>;
}

export interface EventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  nextOccurrenceDate_not?: Maybe<DateTimeInput>;
  nextOccurrenceDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  nextOccurrenceDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  nextOccurrenceDate_lt?: Maybe<DateTimeInput>;
  nextOccurrenceDate_lte?: Maybe<DateTimeInput>;
  nextOccurrenceDate_gt?: Maybe<DateTimeInput>;
  nextOccurrenceDate_gte?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  category?: Maybe<EventCategory>;
  category_not?: Maybe<EventCategory>;
  category_in?: Maybe<EventCategory[] | EventCategory>;
  category_not_in?: Maybe<EventCategory[] | EventCategory>;
  tags?: Maybe<String>;
  tags_not?: Maybe<String>;
  tags_in?: Maybe<String[] | String>;
  tags_not_in?: Maybe<String[] | String>;
  tags_lt?: Maybe<String>;
  tags_lte?: Maybe<String>;
  tags_gt?: Maybe<String>;
  tags_gte?: Maybe<String>;
  tags_contains?: Maybe<String>;
  tags_not_contains?: Maybe<String>;
  tags_starts_with?: Maybe<String>;
  tags_not_starts_with?: Maybe<String>;
  tags_ends_with?: Maybe<String>;
  tags_not_ends_with?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  ticketUrl_not?: Maybe<String>;
  ticketUrl_in?: Maybe<String[] | String>;
  ticketUrl_not_in?: Maybe<String[] | String>;
  ticketUrl_lt?: Maybe<String>;
  ticketUrl_lte?: Maybe<String>;
  ticketUrl_gt?: Maybe<String>;
  ticketUrl_gte?: Maybe<String>;
  ticketUrl_contains?: Maybe<String>;
  ticketUrl_not_contains?: Maybe<String>;
  ticketUrl_starts_with?: Maybe<String>;
  ticketUrl_not_starts_with?: Maybe<String>;
  ticketUrl_ends_with?: Maybe<String>;
  ticketUrl_not_ends_with?: Maybe<String>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpFrId_not?: Maybe<Int>;
  wpFrId_in?: Maybe<Int[] | Int>;
  wpFrId_not_in?: Maybe<Int[] | Int>;
  wpFrId_lt?: Maybe<Int>;
  wpFrId_lte?: Maybe<Int>;
  wpFrId_gt?: Maybe<Int>;
  wpFrId_gte?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  wpEnId_not?: Maybe<Int>;
  wpEnId_in?: Maybe<Int[] | Int>;
  wpEnId_not_in?: Maybe<Int[] | Int>;
  wpEnId_lt?: Maybe<Int>;
  wpEnId_lte?: Maybe<Int>;
  wpEnId_gt?: Maybe<Int>;
  wpEnId_gte?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  possibleDuplicate_not?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  importNotes_not?: Maybe<String>;
  importNotes_in?: Maybe<String[] | String>;
  importNotes_not_in?: Maybe<String[] | String>;
  importNotes_lt?: Maybe<String>;
  importNotes_lte?: Maybe<String>;
  importNotes_gt?: Maybe<String>;
  importNotes_gte?: Maybe<String>;
  importNotes_contains?: Maybe<String>;
  importNotes_not_contains?: Maybe<String>;
  importNotes_starts_with?: Maybe<String>;
  importNotes_not_starts_with?: Maybe<String>;
  importNotes_ends_with?: Maybe<String>;
  importNotes_not_ends_with?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  isRecurring_not?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  recurrencePattern_not?: Maybe<String>;
  recurrencePattern_in?: Maybe<String[] | String>;
  recurrencePattern_not_in?: Maybe<String[] | String>;
  recurrencePattern_lt?: Maybe<String>;
  recurrencePattern_lte?: Maybe<String>;
  recurrencePattern_gt?: Maybe<String>;
  recurrencePattern_gte?: Maybe<String>;
  recurrencePattern_contains?: Maybe<String>;
  recurrencePattern_not_contains?: Maybe<String>;
  recurrencePattern_starts_with?: Maybe<String>;
  recurrencePattern_not_starts_with?: Maybe<String>;
  recurrencePattern_ends_with?: Maybe<String>;
  recurrencePattern_not_ends_with?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
  occurrencesAreUnique_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  OR?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  NOT?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
}

export interface RequestedCitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RequestedCityWhereInput>;
  AND?: Maybe<
    RequestedCitySubscriptionWhereInput[] | RequestedCitySubscriptionWhereInput
  >;
  OR?: Maybe<
    RequestedCitySubscriptionWhereInput[] | RequestedCitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    RequestedCitySubscriptionWhereInput[] | RequestedCitySubscriptionWhereInput
  >;
}

export interface EventUpsertWithWhereUniqueNestedInput {
  where: EventWhereUniqueInput;
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface VenueUpdateManyMutationInput {
  nameFr?: Maybe<String>;
  nameEn?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  city?: Maybe<City>;
  address?: Maybe<String>;
  zip?: Maybe<String>;
  country?: Maybe<String>;
  url?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
}

export interface EventUpdateOneRequiredWithoutOccurrencesInput {
  create?: Maybe<EventCreateWithoutOccurrencesInput>;
  update?: Maybe<EventUpdateWithoutOccurrencesDataInput>;
  upsert?: Maybe<EventUpsertWithoutOccurrencesInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutVenueDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link?: Maybe<String>;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
  occurrences?: Maybe<EventOccurrenceUpdateManyWithoutEventInput>;
}

export interface EventUpdateWithoutOccurrencesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link?: Maybe<String>;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  venue?: Maybe<VenueUpdateOneWithoutEventsInput>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
}

export interface EventUpdateManyWithoutVenueInput {
  create?: Maybe<EventCreateWithoutVenueInput[] | EventCreateWithoutVenueInput>;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutVenueInput[]
    | EventUpdateWithWhereUniqueWithoutVenueInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutVenueInput[]
    | EventUpsertWithWhereUniqueWithoutVenueInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpsertWithoutOccurrencesInput {
  update: EventUpdateWithoutOccurrencesDataInput;
  create: EventCreateWithoutOccurrencesInput;
}

export interface EventCreateManyWithoutVenueInput {
  create?: Maybe<EventCreateWithoutVenueInput[] | EventCreateWithoutVenueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventOccurrenceUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  price?: Maybe<Int>;
  city?: Maybe<City>;
  ticketUrl?: Maybe<String>;
}

export interface UserUpdateInput {
  facebookid?: Maybe<String>;
  fname?: Maybe<String>;
  lname?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  sex?: Maybe<Sex>;
  age?: Maybe<Int>;
  city?: Maybe<City>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  relationship?: Maybe<Relationship>;
  suggestedEvents?: Maybe<EventUpdateManyInput>;
  interestedEvents?: Maybe<EventUpdateManyInput>;
  boringEvents?: Maybe<EventUpdateManyInput>;
  lastInteraction?: Maybe<DateTimeInput>;
  messengerNotifications?: Maybe<Notification>;
}

export interface RequestedCityCreateInput {
  id?: Maybe<ID_Input>;
  city: String;
  user?: Maybe<UserCreateOneInput>;
  sendEmail?: Maybe<Boolean>;
}

export interface EventOccurrenceUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  price?: Maybe<Int>;
  city?: Maybe<City>;
  ticketUrl?: Maybe<String>;
  event?: Maybe<EventUpdateOneRequiredWithoutOccurrencesInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SearchUpdateInput {
  city?: Maybe<City>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  info?: Maybe<String>;
  suggested?: Maybe<Int>;
  user?: Maybe<UserUpdateOneInput>;
  events?: Maybe<EventUpdateManyInput>;
  eventOccurrences?: Maybe<EventOccurrenceUpdateManyInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  facebookid?: Maybe<String>;
  fname?: Maybe<String>;
  lname?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  sex?: Maybe<Sex>;
  age?: Maybe<Int>;
  city?: Maybe<City>;
  permissions?: Maybe<UserCreatepermissionsInput>;
  relationship?: Maybe<Relationship>;
  suggestedEvents?: Maybe<EventCreateManyInput>;
  interestedEvents?: Maybe<EventCreateManyInput>;
  boringEvents?: Maybe<EventCreateManyInput>;
  lastInteraction: DateTimeInput;
  messengerNotifications?: Maybe<Notification>;
}

export type RequestedCityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreatepermissionsInput {
  set?: Maybe<Permission[] | Permission>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  facebookid?: Maybe<String>;
  facebookid_not?: Maybe<String>;
  facebookid_in?: Maybe<String[] | String>;
  facebookid_not_in?: Maybe<String[] | String>;
  facebookid_lt?: Maybe<String>;
  facebookid_lte?: Maybe<String>;
  facebookid_gt?: Maybe<String>;
  facebookid_gte?: Maybe<String>;
  facebookid_contains?: Maybe<String>;
  facebookid_not_contains?: Maybe<String>;
  facebookid_starts_with?: Maybe<String>;
  facebookid_not_starts_with?: Maybe<String>;
  facebookid_ends_with?: Maybe<String>;
  facebookid_not_ends_with?: Maybe<String>;
  fname?: Maybe<String>;
  fname_not?: Maybe<String>;
  fname_in?: Maybe<String[] | String>;
  fname_not_in?: Maybe<String[] | String>;
  fname_lt?: Maybe<String>;
  fname_lte?: Maybe<String>;
  fname_gt?: Maybe<String>;
  fname_gte?: Maybe<String>;
  fname_contains?: Maybe<String>;
  fname_not_contains?: Maybe<String>;
  fname_starts_with?: Maybe<String>;
  fname_not_starts_with?: Maybe<String>;
  fname_ends_with?: Maybe<String>;
  fname_not_ends_with?: Maybe<String>;
  lname?: Maybe<String>;
  lname_not?: Maybe<String>;
  lname_in?: Maybe<String[] | String>;
  lname_not_in?: Maybe<String[] | String>;
  lname_lt?: Maybe<String>;
  lname_lte?: Maybe<String>;
  lname_gt?: Maybe<String>;
  lname_gte?: Maybe<String>;
  lname_contains?: Maybe<String>;
  lname_not_contains?: Maybe<String>;
  lname_starts_with?: Maybe<String>;
  lname_not_starts_with?: Maybe<String>;
  lname_ends_with?: Maybe<String>;
  lname_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  sex?: Maybe<Sex>;
  sex_not?: Maybe<Sex>;
  sex_in?: Maybe<Sex[] | Sex>;
  sex_not_in?: Maybe<Sex[] | Sex>;
  age?: Maybe<Int>;
  age_not?: Maybe<Int>;
  age_in?: Maybe<Int[] | Int>;
  age_not_in?: Maybe<Int[] | Int>;
  age_lt?: Maybe<Int>;
  age_lte?: Maybe<Int>;
  age_gt?: Maybe<Int>;
  age_gte?: Maybe<Int>;
  city?: Maybe<City>;
  city_not?: Maybe<City>;
  city_in?: Maybe<City[] | City>;
  city_not_in?: Maybe<City[] | City>;
  relationship?: Maybe<Relationship>;
  relationship_not?: Maybe<Relationship>;
  relationship_in?: Maybe<Relationship[] | Relationship>;
  relationship_not_in?: Maybe<Relationship[] | Relationship>;
  suggestedEvents_every?: Maybe<EventWhereInput>;
  suggestedEvents_some?: Maybe<EventWhereInput>;
  suggestedEvents_none?: Maybe<EventWhereInput>;
  interestedEvents_every?: Maybe<EventWhereInput>;
  interestedEvents_some?: Maybe<EventWhereInput>;
  interestedEvents_none?: Maybe<EventWhereInput>;
  boringEvents_every?: Maybe<EventWhereInput>;
  boringEvents_some?: Maybe<EventWhereInput>;
  boringEvents_none?: Maybe<EventWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  lastInteraction?: Maybe<DateTimeInput>;
  lastInteraction_not?: Maybe<DateTimeInput>;
  lastInteraction_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastInteraction_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastInteraction_lt?: Maybe<DateTimeInput>;
  lastInteraction_lte?: Maybe<DateTimeInput>;
  lastInteraction_gt?: Maybe<DateTimeInput>;
  lastInteraction_gte?: Maybe<DateTimeInput>;
  messengerNotifications?: Maybe<Notification>;
  messengerNotifications_not?: Maybe<Notification>;
  messengerNotifications_in?: Maybe<Notification[] | Notification>;
  messengerNotifications_not_in?: Maybe<Notification[] | Notification>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface EventCreateManyInput {
  create?: Maybe<EventCreateInput[] | EventCreateInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface VenueCreateInput {
  id?: Maybe<ID_Input>;
  nameFr: String;
  nameEn: String;
  lat: Float;
  long: Float;
  city: City;
  address?: Maybe<String>;
  zip?: Maybe<String>;
  country?: Maybe<String>;
  url?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  events?: Maybe<EventCreateManyWithoutVenueInput>;
  possibleDuplicate?: Maybe<Boolean>;
}

export interface RequestedCityUpdateInput {
  city?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
  sendEmail?: Maybe<Boolean>;
}

export interface EventOccurrenceUpdateManyInput {
  create?: Maybe<EventOccurrenceCreateInput[] | EventOccurrenceCreateInput>;
  update?: Maybe<
    | EventOccurrenceUpdateWithWhereUniqueNestedInput[]
    | EventOccurrenceUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | EventOccurrenceUpsertWithWhereUniqueNestedInput[]
    | EventOccurrenceUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  connect?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  set?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  disconnect?: Maybe<
    EventOccurrenceWhereUniqueInput[] | EventOccurrenceWhereUniqueInput
  >;
  deleteMany?: Maybe<
    EventOccurrenceScalarWhereInput[] | EventOccurrenceScalarWhereInput
  >;
  updateMany?: Maybe<
    | EventOccurrenceUpdateManyWithWhereNestedInput[]
    | EventOccurrenceUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type EventOccurrenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EventUpdateWithWhereUniqueNestedInput {
  where: EventWhereUniqueInput;
  data: EventUpdateDataInput;
}

export interface EventUpdateManyInput {
  create?: Maybe<EventCreateInput[] | EventCreateInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueNestedInput[]
    | EventUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueNestedInput[]
    | EventUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdatepermissionsInput {
  set?: Maybe<Permission[] | Permission>;
}

export interface UserUpdateDataInput {
  facebookid?: Maybe<String>;
  fname?: Maybe<String>;
  lname?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  sex?: Maybe<Sex>;
  age?: Maybe<Int>;
  city?: Maybe<City>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  relationship?: Maybe<Relationship>;
  suggestedEvents?: Maybe<EventUpdateManyInput>;
  interestedEvents?: Maybe<EventUpdateManyInput>;
  boringEvents?: Maybe<EventUpdateManyInput>;
  lastInteraction?: Maybe<DateTimeInput>;
  messengerNotifications?: Maybe<Notification>;
}

export interface VenueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nameFr?: Maybe<String>;
  nameFr_not?: Maybe<String>;
  nameFr_in?: Maybe<String[] | String>;
  nameFr_not_in?: Maybe<String[] | String>;
  nameFr_lt?: Maybe<String>;
  nameFr_lte?: Maybe<String>;
  nameFr_gt?: Maybe<String>;
  nameFr_gte?: Maybe<String>;
  nameFr_contains?: Maybe<String>;
  nameFr_not_contains?: Maybe<String>;
  nameFr_starts_with?: Maybe<String>;
  nameFr_not_starts_with?: Maybe<String>;
  nameFr_ends_with?: Maybe<String>;
  nameFr_not_ends_with?: Maybe<String>;
  nameEn?: Maybe<String>;
  nameEn_not?: Maybe<String>;
  nameEn_in?: Maybe<String[] | String>;
  nameEn_not_in?: Maybe<String[] | String>;
  nameEn_lt?: Maybe<String>;
  nameEn_lte?: Maybe<String>;
  nameEn_gt?: Maybe<String>;
  nameEn_gte?: Maybe<String>;
  nameEn_contains?: Maybe<String>;
  nameEn_not_contains?: Maybe<String>;
  nameEn_starts_with?: Maybe<String>;
  nameEn_not_starts_with?: Maybe<String>;
  nameEn_ends_with?: Maybe<String>;
  nameEn_not_ends_with?: Maybe<String>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  long?: Maybe<Float>;
  long_not?: Maybe<Float>;
  long_in?: Maybe<Float[] | Float>;
  long_not_in?: Maybe<Float[] | Float>;
  long_lt?: Maybe<Float>;
  long_lte?: Maybe<Float>;
  long_gt?: Maybe<Float>;
  long_gte?: Maybe<Float>;
  city?: Maybe<City>;
  city_not?: Maybe<City>;
  city_in?: Maybe<City[] | City>;
  city_not_in?: Maybe<City[] | City>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  zip?: Maybe<String>;
  zip_not?: Maybe<String>;
  zip_in?: Maybe<String[] | String>;
  zip_not_in?: Maybe<String[] | String>;
  zip_lt?: Maybe<String>;
  zip_lte?: Maybe<String>;
  zip_gt?: Maybe<String>;
  zip_gte?: Maybe<String>;
  zip_contains?: Maybe<String>;
  zip_not_contains?: Maybe<String>;
  zip_starts_with?: Maybe<String>;
  zip_not_starts_with?: Maybe<String>;
  zip_ends_with?: Maybe<String>;
  zip_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpFrId_not?: Maybe<Int>;
  wpFrId_in?: Maybe<Int[] | Int>;
  wpFrId_not_in?: Maybe<Int[] | Int>;
  wpFrId_lt?: Maybe<Int>;
  wpFrId_lte?: Maybe<Int>;
  wpFrId_gt?: Maybe<Int>;
  wpFrId_gte?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  wpEnId_not?: Maybe<Int>;
  wpEnId_in?: Maybe<Int[] | Int>;
  wpEnId_not_in?: Maybe<Int[] | Int>;
  wpEnId_lt?: Maybe<Int>;
  wpEnId_lte?: Maybe<Int>;
  wpEnId_gt?: Maybe<Int>;
  wpEnId_gte?: Maybe<Int>;
  events_every?: Maybe<EventWhereInput>;
  events_some?: Maybe<EventWhereInput>;
  events_none?: Maybe<EventWhereInput>;
  possibleDuplicate?: Maybe<Boolean>;
  possibleDuplicate_not?: Maybe<Boolean>;
  AND?: Maybe<VenueWhereInput[] | VenueWhereInput>;
  OR?: Maybe<VenueWhereInput[] | VenueWhereInput>;
  NOT?: Maybe<VenueWhereInput[] | VenueWhereInput>;
}

export interface SearchCreateInput {
  id?: Maybe<ID_Input>;
  city: City;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  info?: Maybe<String>;
  suggested?: Maybe<Int>;
  user?: Maybe<UserCreateOneInput>;
  events?: Maybe<EventCreateManyInput>;
  eventOccurrences?: Maybe<EventOccurrenceCreateManyInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  facebookid?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface EventCreateWithoutVenueInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  shortDescription?: Maybe<String>;
  link: String;
  imageUrl?: Maybe<String>;
  nextOccurrenceDate?: Maybe<DateTimeInput>;
  price?: Maybe<Int>;
  category?: Maybe<EventCategory>;
  tags?: Maybe<String>;
  ticketUrl?: Maybe<String>;
  source?: Maybe<String>;
  wpFrId?: Maybe<Int>;
  wpEnId?: Maybe<Int>;
  possibleDuplicate?: Maybe<Boolean>;
  importNotes?: Maybe<String>;
  isRecurring?: Maybe<Boolean>;
  recurrencePattern?: Maybe<String>;
  occurrencesAreUnique?: Maybe<Boolean>;
  occurrences?: Maybe<EventOccurrenceCreateManyWithoutEventInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VenuePreviousValues {
  id: ID_Output;
  nameFr: String;
  nameEn: String;
  lat: Float;
  long: Float;
  city: City;
  address?: String;
  zip?: String;
  country: String;
  url?: String;
  wpFrId: Int;
  wpEnId: Int;
  possibleDuplicate: Boolean;
}

export interface VenuePreviousValuesPromise
  extends Promise<VenuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nameFr: () => Promise<String>;
  nameEn: () => Promise<String>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  city: () => Promise<City>;
  address: () => Promise<String>;
  zip: () => Promise<String>;
  country: () => Promise<String>;
  url: () => Promise<String>;
  wpFrId: () => Promise<Int>;
  wpEnId: () => Promise<Int>;
  possibleDuplicate: () => Promise<Boolean>;
}

export interface VenuePreviousValuesSubscription
  extends Promise<AsyncIterator<VenuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nameFr: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  long: () => Promise<AsyncIterator<Float>>;
  city: () => Promise<AsyncIterator<City>>;
  address: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  wpFrId: () => Promise<AsyncIterator<Int>>;
  wpEnId: () => Promise<AsyncIterator<Int>>;
  possibleDuplicate: () => Promise<AsyncIterator<Boolean>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Venue {
  id: ID_Output;
  nameFr: String;
  nameEn: String;
  lat: Float;
  long: Float;
  city: City;
  address?: String;
  zip?: String;
  country: String;
  url?: String;
  wpFrId: Int;
  wpEnId: Int;
  possibleDuplicate: Boolean;
}

export interface VenuePromise extends Promise<Venue>, Fragmentable {
  id: () => Promise<ID_Output>;
  nameFr: () => Promise<String>;
  nameEn: () => Promise<String>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  city: () => Promise<City>;
  address: () => Promise<String>;
  zip: () => Promise<String>;
  country: () => Promise<String>;
  url: () => Promise<String>;
  wpFrId: () => Promise<Int>;
  wpEnId: () => Promise<Int>;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  possibleDuplicate: () => Promise<Boolean>;
}

export interface VenueSubscription
  extends Promise<AsyncIterator<Venue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nameFr: () => Promise<AsyncIterator<String>>;
  nameEn: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  long: () => Promise<AsyncIterator<Float>>;
  city: () => Promise<AsyncIterator<City>>;
  address: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  wpFrId: () => Promise<AsyncIterator<Int>>;
  wpEnId: () => Promise<AsyncIterator<Int>>;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  possibleDuplicate: () => Promise<AsyncIterator<Boolean>>;
}

export interface VenueNullablePromise
  extends Promise<Venue | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nameFr: () => Promise<String>;
  nameEn: () => Promise<String>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  city: () => Promise<City>;
  address: () => Promise<String>;
  zip: () => Promise<String>;
  country: () => Promise<String>;
  url: () => Promise<String>;
  wpFrId: () => Promise<Int>;
  wpEnId: () => Promise<Int>;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  possibleDuplicate: () => Promise<Boolean>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventOccurrence {
  id: ID_Output;
  name: String;
  description: String;
  imageUrl: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
  lat: Float;
  long: Float;
  price?: Int;
  city: City;
  ticketUrl?: String;
  createdAt: DateTimeOutput;
}

export interface EventOccurrencePromise
  extends Promise<EventOccurrence>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  imageUrl: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  price: () => Promise<Int>;
  city: () => Promise<City>;
  ticketUrl: () => Promise<String>;
  event: <T = EventPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EventOccurrenceSubscription
  extends Promise<AsyncIterator<EventOccurrence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  lat: () => Promise<AsyncIterator<Float>>;
  long: () => Promise<AsyncIterator<Float>>;
  price: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<City>>;
  ticketUrl: () => Promise<AsyncIterator<String>>;
  event: <T = EventSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventOccurrenceNullablePromise
  extends Promise<EventOccurrence | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  imageUrl: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  price: () => Promise<Int>;
  city: () => Promise<City>;
  ticketUrl: () => Promise<String>;
  event: <T = EventPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateVenue {
  count: Int;
}

export interface AggregateVenuePromise
  extends Promise<AggregateVenue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVenueSubscription
  extends Promise<AsyncIterator<AggregateVenue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface VenueConnection {
  pageInfo: PageInfo;
  edges: VenueEdge[];
}

export interface VenueConnectionPromise
  extends Promise<VenueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VenueEdge>>() => T;
  aggregate: <T = AggregateVenuePromise>() => T;
}

export interface VenueConnectionSubscription
  extends Promise<AsyncIterator<VenueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VenueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVenueSubscription>() => T;
}

export interface User {
  id: ID_Output;
  facebookid?: String;
  fname?: String;
  lname?: String;
  picture?: String;
  email?: String;
  password?: String;
  sex?: Sex;
  age?: Int;
  city?: City;
  permissions: Permission[];
  relationship?: Relationship;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  lastInteraction: DateTimeOutput;
  messengerNotifications: Notification;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  facebookid: () => Promise<String>;
  fname: () => Promise<String>;
  lname: () => Promise<String>;
  picture: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  sex: () => Promise<Sex>;
  age: () => Promise<Int>;
  city: () => Promise<City>;
  permissions: () => Promise<Permission[]>;
  relationship: () => Promise<Relationship>;
  suggestedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interestedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boringEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lastInteraction: () => Promise<DateTimeOutput>;
  messengerNotifications: () => Promise<Notification>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  facebookid: () => Promise<AsyncIterator<String>>;
  fname: () => Promise<AsyncIterator<String>>;
  lname: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<Sex>>;
  age: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<City>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  relationship: () => Promise<AsyncIterator<Relationship>>;
  suggestedEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interestedEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boringEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastInteraction: () => Promise<AsyncIterator<DateTimeOutput>>;
  messengerNotifications: () => Promise<AsyncIterator<Notification>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  facebookid: () => Promise<String>;
  fname: () => Promise<String>;
  lname: () => Promise<String>;
  picture: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  sex: () => Promise<Sex>;
  age: () => Promise<Int>;
  city: () => Promise<City>;
  permissions: () => Promise<Permission[]>;
  relationship: () => Promise<Relationship>;
  suggestedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interestedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boringEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lastInteraction: () => Promise<DateTimeOutput>;
  messengerNotifications: () => Promise<Notification>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RequestedCity {
  id: ID_Output;
  city: String;
  sendEmail: Boolean;
}

export interface RequestedCityPromise
  extends Promise<RequestedCity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  city: () => Promise<String>;
  user: <T = UserPromise>() => T;
  sendEmail: () => Promise<Boolean>;
}

export interface RequestedCitySubscription
  extends Promise<AsyncIterator<RequestedCity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  city: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  sendEmail: () => Promise<AsyncIterator<Boolean>>;
}

export interface RequestedCityNullablePromise
  extends Promise<RequestedCity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  city: () => Promise<String>;
  user: <T = UserPromise>() => T;
  sendEmail: () => Promise<Boolean>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Event {
  id: ID_Output;
  name: String;
  description?: String;
  shortDescription?: String;
  link: String;
  imageUrl: String;
  nextOccurrenceDate?: DateTimeOutput;
  price?: Int;
  category: EventCategory;
  tags?: String;
  ticketUrl?: String;
  source?: String;
  wpFrId: Int;
  wpEnId: Int;
  possibleDuplicate: Boolean;
  importNotes?: String;
  isRecurring: Boolean;
  recurrencePattern?: String;
  occurrencesAreUnique: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  shortDescription: () => Promise<String>;
  link: () => Promise<String>;
  imageUrl: () => Promise<String>;
  nextOccurrenceDate: () => Promise<DateTimeOutput>;
  price: () => Promise<Int>;
  venue: <T = VenuePromise>() => T;
  category: () => Promise<EventCategory>;
  tags: () => Promise<String>;
  ticketUrl: () => Promise<String>;
  source: () => Promise<String>;
  wpFrId: () => Promise<Int>;
  wpEnId: () => Promise<Int>;
  possibleDuplicate: () => Promise<Boolean>;
  importNotes: () => Promise<String>;
  isRecurring: () => Promise<Boolean>;
  recurrencePattern: () => Promise<String>;
  occurrencesAreUnique: () => Promise<Boolean>;
  occurrences: <T = FragmentableArray<EventOccurrence>>(args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  nextOccurrenceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  price: () => Promise<AsyncIterator<Int>>;
  venue: <T = VenueSubscription>() => T;
  category: () => Promise<AsyncIterator<EventCategory>>;
  tags: () => Promise<AsyncIterator<String>>;
  ticketUrl: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  wpFrId: () => Promise<AsyncIterator<Int>>;
  wpEnId: () => Promise<AsyncIterator<Int>>;
  possibleDuplicate: () => Promise<AsyncIterator<Boolean>>;
  importNotes: () => Promise<AsyncIterator<String>>;
  isRecurring: () => Promise<AsyncIterator<Boolean>>;
  recurrencePattern: () => Promise<AsyncIterator<String>>;
  occurrencesAreUnique: () => Promise<AsyncIterator<Boolean>>;
  occurrences: <
    T = Promise<AsyncIterator<EventOccurrenceSubscription>>
  >(args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  shortDescription: () => Promise<String>;
  link: () => Promise<String>;
  imageUrl: () => Promise<String>;
  nextOccurrenceDate: () => Promise<DateTimeOutput>;
  price: () => Promise<Int>;
  venue: <T = VenuePromise>() => T;
  category: () => Promise<EventCategory>;
  tags: () => Promise<String>;
  ticketUrl: () => Promise<String>;
  source: () => Promise<String>;
  wpFrId: () => Promise<Int>;
  wpEnId: () => Promise<Int>;
  possibleDuplicate: () => Promise<Boolean>;
  importNotes: () => Promise<String>;
  isRecurring: () => Promise<Boolean>;
  recurrencePattern: () => Promise<String>;
  occurrencesAreUnique: () => Promise<Boolean>;
  occurrences: <T = FragmentableArray<EventOccurrence>>(args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateSearch {
  count: Int;
}

export interface AggregateSearchPromise
  extends Promise<AggregateSearch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSearchSubscription
  extends Promise<AsyncIterator<AggregateSearch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface SearchConnection {
  pageInfo: PageInfo;
  edges: SearchEdge[];
}

export interface SearchConnectionPromise
  extends Promise<SearchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SearchEdge>>() => T;
  aggregate: <T = AggregateSearchPromise>() => T;
}

export interface SearchConnectionSubscription
  extends Promise<AsyncIterator<SearchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SearchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSearchSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  shortDescription?: String;
  link: String;
  imageUrl: String;
  nextOccurrenceDate?: DateTimeOutput;
  price?: Int;
  category: EventCategory;
  tags?: String;
  ticketUrl?: String;
  source?: String;
  wpFrId: Int;
  wpEnId: Int;
  possibleDuplicate: Boolean;
  importNotes?: String;
  isRecurring: Boolean;
  recurrencePattern?: String;
  occurrencesAreUnique: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  shortDescription: () => Promise<String>;
  link: () => Promise<String>;
  imageUrl: () => Promise<String>;
  nextOccurrenceDate: () => Promise<DateTimeOutput>;
  price: () => Promise<Int>;
  category: () => Promise<EventCategory>;
  tags: () => Promise<String>;
  ticketUrl: () => Promise<String>;
  source: () => Promise<String>;
  wpFrId: () => Promise<Int>;
  wpEnId: () => Promise<Int>;
  possibleDuplicate: () => Promise<Boolean>;
  importNotes: () => Promise<String>;
  isRecurring: () => Promise<Boolean>;
  recurrencePattern: () => Promise<String>;
  occurrencesAreUnique: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  nextOccurrenceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  price: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<EventCategory>>;
  tags: () => Promise<AsyncIterator<String>>;
  ticketUrl: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  wpFrId: () => Promise<AsyncIterator<Int>>;
  wpEnId: () => Promise<AsyncIterator<Int>>;
  possibleDuplicate: () => Promise<AsyncIterator<Boolean>>;
  importNotes: () => Promise<AsyncIterator<String>>;
  isRecurring: () => Promise<AsyncIterator<Boolean>>;
  recurrencePattern: () => Promise<AsyncIterator<String>>;
  occurrencesAreUnique: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Search {
  id: ID_Output;
  createdAt: DateTimeOutput;
  city: City;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  info?: String;
  suggested: Int;
}

export interface SearchPromise extends Promise<Search>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  city: () => Promise<City>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  info: () => Promise<String>;
  suggested: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventOccurrences: <T = FragmentableArray<EventOccurrence>>(args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SearchSubscription
  extends Promise<AsyncIterator<Search>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  city: () => Promise<AsyncIterator<City>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  info: () => Promise<AsyncIterator<String>>;
  suggested: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventOccurrences: <
    T = Promise<AsyncIterator<EventOccurrenceSubscription>>
  >(args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SearchNullablePromise
  extends Promise<Search | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  city: () => Promise<City>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  info: () => Promise<String>;
  suggested: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  eventOccurrences: <T = FragmentableArray<EventOccurrence>>(args?: {
    where?: EventOccurrenceWhereInput;
    orderBy?: EventOccurrenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateEventOccurrence {
  count: Int;
}

export interface AggregateEventOccurrencePromise
  extends Promise<AggregateEventOccurrence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventOccurrenceSubscription
  extends Promise<AsyncIterator<AggregateEventOccurrence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RequestedCityEdge {
  node: RequestedCity;
  cursor: String;
}

export interface RequestedCityEdgePromise
  extends Promise<RequestedCityEdge>,
    Fragmentable {
  node: <T = RequestedCityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequestedCityEdgeSubscription
  extends Promise<AsyncIterator<RequestedCityEdge>>,
    Fragmentable {
  node: <T = RequestedCitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventOccurrenceSubscriptionPayload {
  mutation: MutationType;
  node: EventOccurrence;
  updatedFields: String[];
  previousValues: EventOccurrencePreviousValues;
}

export interface EventOccurrenceSubscriptionPayloadPromise
  extends Promise<EventOccurrenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventOccurrencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventOccurrencePreviousValuesPromise>() => T;
}

export interface EventOccurrenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventOccurrenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventOccurrenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventOccurrencePreviousValuesSubscription>() => T;
}

export interface VenueSubscriptionPayload {
  mutation: MutationType;
  node: Venue;
  updatedFields: String[];
  previousValues: VenuePreviousValues;
}

export interface VenueSubscriptionPayloadPromise
  extends Promise<VenueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VenuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VenuePreviousValuesPromise>() => T;
}

export interface VenueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VenueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VenueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VenuePreviousValuesSubscription>() => T;
}

export interface EventOccurrencePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  imageUrl: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
  lat: Float;
  long: Float;
  price?: Int;
  city: City;
  ticketUrl?: String;
  createdAt: DateTimeOutput;
}

export interface EventOccurrencePreviousValuesPromise
  extends Promise<EventOccurrencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  imageUrl: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  price: () => Promise<Int>;
  city: () => Promise<City>;
  ticketUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EventOccurrencePreviousValuesSubscription
  extends Promise<AsyncIterator<EventOccurrencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  lat: () => Promise<AsyncIterator<Float>>;
  long: () => Promise<AsyncIterator<Float>>;
  price: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<City>>;
  ticketUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventOccurrenceEdge {
  node: EventOccurrence;
  cursor: String;
}

export interface EventOccurrenceEdgePromise
  extends Promise<EventOccurrenceEdge>,
    Fragmentable {
  node: <T = EventOccurrencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventOccurrenceEdgeSubscription
  extends Promise<AsyncIterator<EventOccurrenceEdge>>,
    Fragmentable {
  node: <T = EventOccurrenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  facebookid?: String;
  fname?: String;
  lname?: String;
  picture?: String;
  email?: String;
  password?: String;
  sex?: Sex;
  age?: Int;
  city?: City;
  permissions: Permission[];
  relationship?: Relationship;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  lastInteraction: DateTimeOutput;
  messengerNotifications: Notification;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  facebookid: () => Promise<String>;
  fname: () => Promise<String>;
  lname: () => Promise<String>;
  picture: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  sex: () => Promise<Sex>;
  age: () => Promise<Int>;
  city: () => Promise<City>;
  permissions: () => Promise<Permission[]>;
  relationship: () => Promise<Relationship>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lastInteraction: () => Promise<DateTimeOutput>;
  messengerNotifications: () => Promise<Notification>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  facebookid: () => Promise<AsyncIterator<String>>;
  fname: () => Promise<AsyncIterator<String>>;
  lname: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<Sex>>;
  age: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<City>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  relationship: () => Promise<AsyncIterator<Relationship>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastInteraction: () => Promise<AsyncIterator<DateTimeOutput>>;
  messengerNotifications: () => Promise<AsyncIterator<Notification>>;
}

export interface RequestedCitySubscriptionPayload {
  mutation: MutationType;
  node: RequestedCity;
  updatedFields: String[];
  previousValues: RequestedCityPreviousValues;
}

export interface RequestedCitySubscriptionPayloadPromise
  extends Promise<RequestedCitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequestedCityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequestedCityPreviousValuesPromise>() => T;
}

export interface RequestedCitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequestedCitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequestedCitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequestedCityPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface SearchPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  city: City;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  info?: String;
  suggested: Int;
}

export interface SearchPreviousValuesPromise
  extends Promise<SearchPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  city: () => Promise<City>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  info: () => Promise<String>;
  suggested: () => Promise<Int>;
}

export interface SearchPreviousValuesSubscription
  extends Promise<AsyncIterator<SearchPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  city: () => Promise<AsyncIterator<City>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  info: () => Promise<AsyncIterator<String>>;
  suggested: () => Promise<AsyncIterator<Int>>;
}

export interface SearchSubscriptionPayload {
  mutation: MutationType;
  node: Search;
  updatedFields: String[];
  previousValues: SearchPreviousValues;
}

export interface SearchSubscriptionPayloadPromise
  extends Promise<SearchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SearchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SearchPreviousValuesPromise>() => T;
}

export interface SearchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SearchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SearchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SearchPreviousValuesSubscription>() => T;
}

export interface EventOccurrenceConnection {
  pageInfo: PageInfo;
  edges: EventOccurrenceEdge[];
}

export interface EventOccurrenceConnectionPromise
  extends Promise<EventOccurrenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventOccurrenceEdge>>() => T;
  aggregate: <T = AggregateEventOccurrencePromise>() => T;
}

export interface EventOccurrenceConnectionSubscription
  extends Promise<AsyncIterator<EventOccurrenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventOccurrenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventOccurrenceSubscription>() => T;
}

export interface RequestedCityPreviousValues {
  id: ID_Output;
  city: String;
  sendEmail: Boolean;
}

export interface RequestedCityPreviousValuesPromise
  extends Promise<RequestedCityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  city: () => Promise<String>;
  sendEmail: () => Promise<Boolean>;
}

export interface RequestedCityPreviousValuesSubscription
  extends Promise<AsyncIterator<RequestedCityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  city: () => Promise<AsyncIterator<String>>;
  sendEmail: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateRequestedCity {
  count: Int;
}

export interface AggregateRequestedCityPromise
  extends Promise<AggregateRequestedCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequestedCitySubscription
  extends Promise<AsyncIterator<AggregateRequestedCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SearchEdge {
  node: Search;
  cursor: String;
}

export interface SearchEdgePromise extends Promise<SearchEdge>, Fragmentable {
  node: <T = SearchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SearchEdgeSubscription
  extends Promise<AsyncIterator<SearchEdge>>,
    Fragmentable {
  node: <T = SearchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VenueEdge {
  node: Venue;
  cursor: String;
}

export interface VenueEdgePromise extends Promise<VenueEdge>, Fragmentable {
  node: <T = VenuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VenueEdgeSubscription
  extends Promise<AsyncIterator<VenueEdge>>,
    Fragmentable {
  node: <T = VenueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequestedCityConnection {
  pageInfo: PageInfo;
  edges: RequestedCityEdge[];
}

export interface RequestedCityConnectionPromise
  extends Promise<RequestedCityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequestedCityEdge>>() => T;
  aggregate: <T = AggregateRequestedCityPromise>() => T;
}

export interface RequestedCityConnectionSubscription
  extends Promise<AsyncIterator<RequestedCityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequestedCityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequestedCitySubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "Sex",
    embedded: false
  },
  {
    name: "Relationship",
    embedded: false
  },
  {
    name: "EventCategory",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "EventOccurrence",
    embedded: false
  },
  {
    name: "Venue",
    embedded: false
  },
  {
    name: "RequestedCity",
    embedded: false
  },
  {
    name: "Search",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
